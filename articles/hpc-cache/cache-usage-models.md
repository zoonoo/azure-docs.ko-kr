---
title: Azure HPC Cache 사용 모델
description: 다양한 캐시 사용 모델에 대해 알아보고 이러한 모델 중에서 선택하여 읽기 전용 또는 읽기/쓰기 캐싱을 설정하고 기타 캐싱 설정을 제어하는 방법을 설명합니다.
author: ekpgh
ms.service: hpc-cache
ms.topic: how-to
ms.date: 04/08/2021
ms.author: v-erkel
ms.openlocfilehash: 7e1b11fd15cca9b11fc627222318f08d31743336
ms.sourcegitcommit: 79c9c95e8a267abc677c8f3272cb9d7f9673a3d7
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/19/2021
ms.locfileid: "107719190"
---
# <a name="understand-cache-usage-models"></a>캐시 사용 모델 이해

캐시 사용 모델을 사용하면 Azure HPC Cache에서 워크플로 속도를 높이기 위해 파일을 저장하는 방법을 사용자 지정할 수 있습니다.

## <a name="basic-file-caching-concepts"></a>기본 파일 캐싱 개념

파일 캐싱은 Azure HPC Cache가 클라이언트 요청을 신속하게 처리하는 방법입니다. 다음과 같은 기본 방법을 사용합니다.

* **읽기 캐싱** - Azure HPC Cache는 클라이언트가 스토리지 시스템에서 요청하는 파일의 복사본을 유지합니다. 다음 번에 클라이언트가 동일한 파일을 요청하면 HPC Cache는 백 엔드 스토리지 시스템에서 다시 가져올 필요 없이 해당 캐시에 있는 버전을 제공할 수 있습니다.

* **쓰기 캐싱** - 선택적으로 Azure HPC Cache는 클라이언트 머신에서 전송된 변경된 파일의 복사본을 저장할 수 있습니다. 여러 클라이언트에서 짧은 기간 동안 동일한 파일을 변경하는 경우 백 엔드 스토리지 시스템에 각 변경 내용을 개별적으로 쓰지 않고 캐시의 모든 변경 내용을 수집할 수 있습니다.

  지정된 시간 동안 변경 내용이 없는 경우 캐시는 장기 스토리지 시스템으로 파일을 이동합니다.

  쓰기 캐싱이 사용하지 않도록 설정되어 있으면 캐시에서 변경된 파일을 저장하지 않고 백 엔드 스토리지 시스템에 즉시 씁니다.

* **쓰기 저장 지연** - 쓰기 캐싱이 설정된 캐시의 경우 쓰기 저장 지연은 파일을 백 엔드 스토리지 시스템으로 복사하기 전에 캐시가 추가 파일 변경을 대기하는 시간입니다.

* **백 엔드 확인** - 백 엔드 확인 설정은 캐시가 백 엔드 스토리지 시스템의 원격 버전과 파일의 로컬 복사본을 비교하는 주기를 결정합니다. 백 엔드 복사본이 캐시된 복사본보다 최신인 경우 캐시는 원격 복사본을 가져온 후 후속 요청을 위해 저장합니다.

  백 엔드 확인 설정은 캐시가 해당 파일을 원격 스토리지의 소스 파일과 *자동으로* 비교하는 경우를 보여 줍니다. 그러나 Azure HPC Cache가 readdirplus 요청을 포함하는 디렉터리 작업을 수행하여 강제로 파일을 비교하도록 할 수 있습니다. readdirplus는 디렉터리 메타데이터를 반환하는 표준 NFS API(확장된 읽기라고도 함)로, 캐시에서 파일을 비교하고 업데이트하도록 합니다.

Azure HPC Cache에 기본 제공되는 사용 모델은 이러한 설정에 대해 다른 값을 가지므로 사용자의 상황에 가장 적합한 조합을 선택할 수 있습니다.

## <a name="choose-the-right-usage-model-for-your-workflow"></a>워크플로에 적합한 사용 모델 선택

사용하는 각 NFS 프로토콜 스토리지 대상에 대한 사용 모델을 선택해야 합니다. Azure Blob 스토리지 대상에는 사용자 지정할 수 없는 기본 제공 사용 모델이 있습니다.

HPC Cache 사용 모델을 사용하여 빠른 응답과 부실 데이터를 가져올 위험 간에 균형을 유지하는 방법을 선택할 수 있습니다. 파일 읽기 속도를 최적화하려면 캐시의 파일을 백 엔드 파일과 비교해서 확인하는지 여부는 중요하지 않을 수 있습니다. 반면에 파일을 원격 스토리지에서 항상 최신 상태로 유지하려면 자주 확인하는 모델을 선택합니다.

사용 모델 옵션은 다음과 같습니다.

* **대량의, 드문 쓰기 읽기** - 고정 상태이거나 거의 변경되지 않는 파일에 대한 읽기 액세스를 가속화하려면 이 옵션을 사용합니다.

  이 옵션은 클라이언트 읽기를 캐시하지만 쓰기를 캐시하지 않습니다. 즉시 백 엔드 스토리지에 쓰기를 전달합니다.
  
  캐시에 저장된 파일은 NFS 스토리지 볼륨의 파일과 자동으로 비교되지 않습니다. (위의 백 엔드 확인에 대한 설명을 읽고 수동으로 비교하는 방법을 알아보세요.)

  파일을 캐시에 먼저 쓰지 않고 스토리지 시스템에서 직접 수정될 수 있는 위험 요소가 있으면 이 옵션을 사용하지 마세요. 이 경우 파일의 캐시된 버전이 백 엔드 파일과 동기화되지 않습니다.

* **15% 쓰기보다 큼** - 이 옵션을 선택하면 읽기 및 쓰기 성능이 향상됩니다. 이 옵션을 사용하는 경우 모든 클라이언트는 백 엔드 스토리지를 직접 탑재하는 대신, Azure HPC Cache를 통해 파일에 액세스해야 합니다. 캐시된 파일은 아직 백 엔드에 복사되지 않은 최근 변경 내용을 포함하게 됩니다.

  이 사용 모델에서 캐시의 파일은 8시간마다 백 엔드 스토리지에 있는 파일과만 비교됩니다. 파일의 캐시된 버전은 좀 더 최신 버전으로 간주됩니다. 캐시의 수정된 파일은 추가로 변경되지 않고 20분 동안 캐시에 있다가 백 엔드<!-- an hour --> 스토리지 시스템에 기록됩니다.

* **클라이언트가 캐시를 무시하는 NFS 대상에 씁니다.** - 워크플로의 클라이언트에서 먼저 캐시에 쓰지 않고 스토리지 시스템에 직접 데이터를 쓰거나 데이터 일관성을 최적화하려는 경우 이 옵션을 선택합니다. 클라이언트에서 요청하는 파일이 캐시(읽기)되지만 클라이언트에서 해당 파일에 대한 변경 내용(쓰기)은 캐시되지 않습니다. 백 엔드 스토리지 시스템에 직접 전달됩니다.

  이 사용 모델에서 캐시의 파일은 업데이트의 백 엔드 버전과 비교해서 자주(30초마다) 확인됩니다. 이 확인을 통해 데이터 일관성을 유지하면서 캐시 외부에서 파일을 변경할 수 있습니다.

  > [!TIP]
  > 이러한 처음 세 가지 기본 사용 모델을 사용하여 대부분의 Azure HPC Cache 워크플로를 처리할 수 있습니다. 다음 옵션은 덜 일반적인 시나리오에 적합합니다.

* **15% 쓰기보다 큼, 30초마다 백업 서버에서 변경 내용 확인** 및 **15% 쓰기보다 큼, 60초마다 백업 서버에서 변경 내용 확인** - 이러한 옵션은 읽기 및 쓰기 속도를 향상시키려는 워크플로용으로 디자인되었지만 다른 사용자가 백 엔드 스토리지 시스템에 직접 쓸 가능성이 있습니다. 예를 들어, 여러 클라이언트 모음이 서로 다른 위치의 동일한 파일을 사용해서 작업하는 경우 이러한 사용 모델은 파일에 빠르게 액세스해야 할 필요성과 원본의 부실 콘텐츠에 대해 낮은 허용 오차를 유지할 때의 이점을 적절히 고려하는 것이 유용할 수 있습니다.

* **15% 쓰기보다 큼, 30초마다 서버에 다시 쓰기** - 이 옵션은 여러 클라이언트가 동일한 파일을 적극적으로 수정하거나, 일부 클라이언트가 캐시를 탑재하는 대신 백 엔드 스토리지에 직접 액세스하는 시나리오를 위해 디자인되었습니다.

  빈번한 백 엔드 쓰기는 캐시 성능에 영향을 주므로 파일 충돌 위험이 낮은 경우(예: 서로 다른 클라이언트가 동일한 파일 세트의 서로 다른 영역에서 작업하는 경우) **15% 쓰기보다 큼** 사용 모델을 사용하는 것이 좋습니다.

* **대량의 읽기, 3시간마다 백업 서버 확인** - 이 옵션은 클라이언트 쪽에서 빠른 읽기에 우선 순위를 부여할 뿐만 아니라 **대량의, 드문 쓰기 읽기** 와 달리 백 엔드 스토리지 시스템에서 캐시된 파일을 정기적으로 새로 고칩니다.

이 표에는 사용 모델의 차이점이 요약되어 있습니다.

[!INCLUDE [usage-models-table.md](includes/usage-models-table.md)]

Azure HPC Cache 워크플로의 최고 사용 모델에 대해 질문이 있는 경우 Azure 담당자에게 문의하거나 지원 요청을 여세요.

## <a name="know-when-to-remount-clients-for-nlm"></a>NLM을 위해 클라이언트를 다시 탑재해야 하는 시점 파악

경우에 따라 스토리지 대상의 사용 모델을 변경하는 경우 클라이언트를 다시 탑재해야 할 수 있습니다. 이는 다양한 사용 모델이 NLM(네트워크 잠금 관리자) 요청을 처리하는 방식 때문에 필요합니다.

HPC Cache는 클라이언트와 백엔드 스토리지 시스템 사이에 위치합니다. 일반적으로 캐시는 NLM 요청을 백엔드 스토리지 시스템으로 전달하지만 경우에 따라 캐시 자체가 NLM 요청을 승인하고 클라이언트에 값을 반환합니다. Azure HPC Cache에서 이는 **대량의 드문 쓰기 읽기** 사용 모델(또는 구성 가능한 사용 모델이 없는 표준 Blob Storage 대상 사용)을 사용할 때만 발생합니다.

**대량의 드문 쓰기 읽기** 사용 모델과 다른 사용 모델 간에 변경하는 경우 파일 충돌 위험이 약간 있습니다. 현재 NLM 상태를 캐시에서 스토리지 시스템으로 또는 그 반대로 전송할 수 있는 방법은 없습니다. 따라서 클라이언트의 잠금 상태는 정확하지 않습니다.

새 잠금 관리자를 사용하여 정확한 NLM 상태를 갖도록 클라이언트를 다시 탑재합니다.

사용 모델 또는 백엔드 스토리지가 지원하지 않을 때 클라이언트가 NLM 요청을 보내면 오류가 수신됩니다.

### <a name="disable-nlm-at-client-mount-time"></a>클라이언트 탑재 시 NLM 사용 안 함

클라이언트 시스템에서 NLM 요청을 보낼지 여부를 항상 쉽게 알 수 있는 것은 아닙니다.

클라이언트가 ``mount`` 명령에 ``-o nolock`` 옵션을 사용하여 클러스터를 탑재할 때 NLM을 사용하지 않도록 설정할 수 있습니다.

``nolock`` 옵션의 정확한 동작은 클라이언트 운영 체제에 따라 다르므로 클라이언트 OS에 대한 탑재 설명서(man 5 nfs)를 확인합니다. 대부분의 경우 잠금을 로컬로 클라이언트로 이동합니다. 애플리케이션이 여러 클라이언트에서 파일을 잠그는 경우 주의해야 합니다.

> [!NOTE]
> ADLS-NFS는 NLM을 지원하지 않습니다. ADLS-NFS 스토리지 대상을 사용하는 경우 위의 탑재 옵션을 사용하여 NLM을 사용하지 않도록 설정해야 합니다.

## <a name="next-steps"></a>다음 단계

* Azure HPC Cache에 [스토리지 대상 추가](hpc-cache-add-storage.md)
