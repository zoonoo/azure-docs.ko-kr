<properties
   pageTitle="확장성 검사 목록 | Microsoft Azure"
   description="Azure 자동 크기 조정에 대한 디자인 고려 사항을 제공하는 확장성 검사 목록 지침"
   services=""
   documentationCenter="na"
   authors="dragon119"
   manager="masimms"
   editor=""
   tags=""/>

<tags
   ms.service="best-practice"
   ms.devlang="na"
   ms.topic="article"
   ms.tgt_pltfrm="na"
   ms.workload="na"
   ms.date="04/28/2015"
   ms.author="masashin"/>

# 확장성 검사 목록

![](media/best-practices-scalability-checklist/pnp-logo.png)

## 서비스 디자인
- **워크로드 분할**. 관심 분야의 분리에 대한 일반적인 규칙 및 단일 책임 원칙을 따르면서 프로세스의 각 부분을 불연속 및 분해되도록 디자인하여 각 부분의 크기를 최소화합니다. 이렇게 하면 각 계산 단위(예: 역할 또는 데이터베이스 서버)의 사용을 극대화하고, 특정 리소스의 인스턴스를 추가하여 응용 프로그램을 보다 쉽게 확장할 수 있도록 하는 방식으로 구성 요소 부분을 분산시킬 수 있습니다. 자세한 내용은 [계산 분할 지침](https://msdn.microsoft.com/library/dn568099.aspx)을 참조하세요.
- **크기 조정을 고려한 디자인**. 크기 조정을 사용하면 응용 프로그램에서 사용하는 역할, 큐 및 기타 서비스의 인스턴스 수를 늘리거나 줄여 가변 부하에 대응할 수 있습니다. 그러나 이 점을 염두에 두고 응용 프로그램을 디자인해야 합니다. 예를 들어 응용 프로그램과 응용 프로그램에서 사용하는 서비스는 요청이 모든 인스턴스로 라우팅되고 특정 인스턴스의 추가 또는 제거가 현재 사용자에게 부정적인 영향을 주지 않도록 상태를 저장하지 않아야 합니다. 또한 인스턴스가 추가 및 제거될 때 응용 프로그램의 코드가 필요한 라우팅을 수행할 수 있도록 인스턴스의 구성 또는 자동 검색을 구현해야 합니다. 예를 들어 웹 응용 프로그램은 라운드 로빈 방식으로 큐 집합을 사용하여 작업자 역할에서 실행되는 백그라운드 서비스로 요청을 라우팅할 수 있습니다. 성공적으로 요청을 라우팅하고 응용 프로그램의 부하를 분산시키기 위해서는 웹 응용 프로그램에서 큐 수 변경을 검색할 수 있어야 합니다.
- **단위로 크기 조정**. 규모 증가에 맞게 리소스를 추가할 계획을 수립합니다. 각 리소스에 대해 크기 조정 상한을 알고 이러한 한도를 초과하려면 분할 또는 분해를 사용해야 합니다. 잘 정의된 리소스 집합을 기준으로 시스템에 대한 배율 단위를 결정합니다. 이렇게 하면 규모 확장 작업을 보다 쉽게 적용할 수 있으며, 전체 시스템의 일부분에서 리소스 부족으로 인해 응용 프로그램이 부정적인 영향을 받을 가능성이 줄어듭니다. 예를 들어 x개의 웹 및 작업자 역할을 추가하려면 역할에서 생성되는 추가 워크로드를 처리하기 위해 y개의 추가 쿼리 및 z개의 저장소 계정이 필요할 수 있으므로 배율 단위는 x개의 웹 및 작업자 역할, _y_개의 큐 및 _z_개의 저장소 계정으로 구성됩니다. 하나 이상의 배율 단위를 추가하여 쉽게 확장할 수 있도록 응용 프로그램을 디자인하세요.
- **클라이언트 선호도 방지**. 가능한 경우, 응용 프로그램에서 선호도를 요구하지 않도록 하여 요청이 모든 인스턴스로 라우팅될 수 있고 인스턴스 수가 관련이 없도록 해야 합니다. 이는 각 사용자의 상태 정보에 대한 저장, 검색 및 유지 관리 오버헤드도 방지합니다.
- **플랫폼 자동 크기 조정 기능 활용**. 호스팅 플랫폼이 Azure 자동 크기 조정과 같은 자동 크기 조정 기능을 지원하는 경우 기본 제공 메커니즘이 요구 사항을 이행할 수 없는 경우가 아니라면 사용자 지정 또는 타사 메커니즘으로 기본 설정합니다. 가능한 경우 예약된 크기 조정 규칙을 사용하여 시작 지연 없이 리소스를 사용할 수 있도록 하되, 예기치 않은 수요 변화에 대처하기 위해 적절한 경우 규칙에 반응적 자동 크기 조정을 추가하세요. 서비스 관리 API에 자동 크기 조정 작업을 사용하여 자동 크기 조정을 미세 조정하고 웹 포털에서 사용할 수 있는 구성 옵션 외에 규칙에 사용자 지정 카운터를 추가할 수 있습니다. 자세한 내용은 [자동 크기 조정 지침](best-practices-auto-scaling.md) 페이지를 참조하세요.
- **집약적인 CPU/IO 작업을 백그라운드 작업으로 오프로드**. 서비스 요청을 실행하는 데 시간이 오래 걸리거나 많은 리소스가 사용될 것으로 예상되는 경우 이 요청 처리를 별도 작업으로 오프로드합니다. 호스팅 플랫폼에 따라 작업자 역할 또는 백그라운드 작업을 사용하여 이러한 작업을 실행할 수 있습니다. 이 전략을 사용하면 서비스가 추가 요청을 계속 받고 응답을 유지할 수 있습니다. 자세한 내용은 [백그라운드 작업 지침](best-practices-background-jobs.md)을 참조하세요.
- **백그라운드 작업에 대한 워크로드 분산**. 많은 백그라운드 작업이 있거나 작업에 상당한 시간 또는 리소스가 필요한 경우 여러 계산 단위(예: 작업자 역할 또는 백그라운드 작업)로 작업을 분산합니다. [경쟁 소비자 패턴](https://msdn.microsoft.com/library/dn568101.aspx)은 한 가지 가능한 해결책을 제공합니다.
- **_Shared Nothing_ 아키텍처로 전환**. Shared Nothing 아키텍처는 공유 서비스 또는 저장소와 같은 단일 경합 지점이 없는 독립 노드 및 자가 충족 노드를 사용합니다. 이론적으로 이러한 시스템은 거의 무제한적으로 확장될 수 있습니다. 완전한 Shared Nothing 접근 방법은 일반적으로 대부분의 응용 프로그램에 현실적이지 않지만 더 나은 확장성을 위한 디자인 기회를 제공할 수 있습니다. 예를 들어 서버 쪽 세션 상태, 클라이언트 선호도 및 데이터 분할을 사용하지 못하도록 하는 것은 Shared Nothing 아키텍처로 전환하는 좋은 예입니다.

## 데이터 관리

- **데이터 분할 사용**. 데이터를 여러 데이터베이스 및 데이터베이스 서버로 분할하거나, 이러한 분할을 투명하게 제공할 수 있는 데이터 저장소 서비스(예: Azure SQL 데이터베이스 탄력적인 확장 및 Azure 테이블 저장소)를 사용하도록 응용 프로그램을 디자인합니다. 이 접근 방법은 성능을 극대화하고 크기 조정을 간편하게 해줍니다. 수평, 수직 및 기능 분할과 같은 여러 가지 분할 기술이 있으며, 이러한 기술의 조합을 사용하여 향상된 쿼리 성능, 간편한 확장성, 보다 유연한 관리, 더 나은 가용성 등의 이점을 극대화하고 저장소 유형을 해당 데이터에 일치시킬 수 있습니다. 또한 특정 데이터 형식에 최적화된 정도에 따라 형식을 선택하여 다양한 데이터 형식에 서로 다른 유형의 데이터 저장소를 사용하는 것이 좋습니다. 여기에는 관계형 데이터베이스 대신 또는 관계형 데이터베이스와 함께 테이블 저장소, 문서 데이터베이스 또는 열 패밀리 데이터 저장소를 사용하는 것이 포함될 수 있습니다.니다. 자세한 내용은 [데이터 분할 지침](best-practices-data-partitioning.md)을 참조하세요.
- **결과적 일관성을 위한 디자인**. 결과적 일관성은 여러 저장소에 분할된 관련 데이터를 동기화하는 데 필요한 시간을 줄이거나 제거하여 확장성을 향상시킵니다. 하지만 데이터를 읽을 때 데이터가 일관적이지 않을 수 있고 일부 쓰기 작업이 충돌을 일으킬 수 있습니다. 결과적 일관성은 동일한 데이터의 읽기 빈도는 높은 반면, 쓰기 빈도는 낮은 경우에 이상적입니다. 자세한 내용은 [데이터 일관성 지침](#insertlink#)을 참조하세요.
- **구성 요소와 서비스 간의 수다스러운 상호 작용 감소**. 응용 프로그램이 한 번의 호출로 모든 데이터를 반환하는 것이 아니라 서비스를 여러 번 호출(각 호출에서 소량의 데이터 반환)해야 하는 경우 서비스에 대한 _수다스러운_ 인터페이스 디자인을 피해야 합니다. 가능한 경우, 대기 시간이 긴 서비스 또는 구성 요소를 호출하는 경우 여러 관련 작업을 단일 요청으로 결합합니다. 이렇게 하면 성능을 모니터링하고 복잡한 작업을 최적화하는 것이 쉬워집니다. 예를 들어 데이터베이스의 저장 프로시저를 사용하여 복잡한 논리를 캡슐화하고 왕복 및 리소스 잠금 횟수를 줄입니다. 
- **큐를 사용하여 고속 데이터 쓰기에 대한 부하 평준화**. 서비스 요청이 급증하면 해당 서비스에 과부하가 걸리고 오류가 급증할 수 있습니다. 이를 방지하려면 [큐 기반 부하 평준화 패턴](https://msdn.microsoft.com/library/dn589783.aspx)을 구현하는 것이 좋습니다. 서비스 실패 또는 작업 시간 초과를 일으킬 수 있는 일시적 과부하를 원활하게 유지하려면 작업과 해당 작업에서 호출하는 서비스 간의 버퍼 역할을 하는 큐를 사용합니다.
- **데이터 저장소에 대한 부하 최소화**. 데이터 저장소는 일반적으로 처리 병목 지점인 동시에 비용이 많이 드는 리소스이므로 규모를 쉽게 확장할 수 없는 경우가 많습니다. 가능한 경우, 데이터 저장소에서 논리(예: XML 문서 또는 JSON 개체 처리)를 제거하고 응용 프로그램 내에서 처리를 수행하세요. 예를 들어 데이터베이스로 XML(저장소에 대한 불투명 문자열 제외)을 전달하는 대신 응용 프로그램 계층 내에서 XML을 serialize 또는 deserialize하여 데이터 저장소에 네이티브한 형식으로 전달합니다. 일반적으로 데이터 저장소보다 응용 프로그램이 규모를 확장하기 훨씬 쉬우므로 계산 집약적인 처리는 대부분 응용 프로그램 내에서 수행해야 합니다.
- **검색되는 데이터 양 최소화**. 열을 지정하고 조건을 사용하여 행을 선택하는 방식으로 필요한 데이터만 검색합니다. 테이블 값 매개 변수 및 적절한 격리 수준을 사용합니다. Etag같은 메커니즘을 사용하여 불필요한 데이터 검색을 방지합니다.
- **적극적으로 캐싱 사용**. 가급적 캐싱을 사용하여 데이터를 생성하거나 전달하는 리소스 및 서비스에 대한 부하를 줄입니다. 캐싱은 일반적으로 비교적 정적인 데이터 또는 가져오기 위해 상당한 처리가 필요한 데이터에 적합합니다. 캐싱은 해당되는 경우 데이터 액세스 및 UI 생성을 포함하여 응용 프로그램의 각 계층 내 모든 수준에서 발생해야 합니다. 자세한 내용은 [캐싱 지침](best-practices-caching.md)을 참조하세요.
- **데이터 증가 및 보존 처리**. 응용 프로그램에서 저장하는 데이터 양은 시간이 지남에 따라 증가합니다. 이로 인해 저장소 비용을 증가하고 데이터 액세스 대기 시간이 증가하며, 이는 응용 프로그램 처리량 및 성능에 영향을 줍니다. 더 이상 액세스하지 않는 오래된 데이터의 일부를 주기적으로 보관하거나, 거의 액세스하지 않는 데이터를 액세스 대기 시간이 더 긴 경우에도 보다 비용 효율적인 장기 저장소로 이동할 수 있습니다.
- **효율적인 이진 형식을 사용하여 DTO 최적화**. 데이터 전송 개체는 응용 프로그램 계층 간에 여러 번 전달되므로 크기를 최소화하면 리소스 및 네트워크에 대한 부하가 감소합니다. 그러나 데이터를 해당 데이터가 사용되는 각 위치에서 필요한 형식으로 변환하는 오버헤드와 비용 절감의 균형을 유지하고, 상호 운용성이 가장 뛰어난 형식을 채택하여 구성 요소를 손쉽게 다시 사용할 수 있도록 해야 합니다.
- **캐시 제어 설정**. 가능한 경우 출력 캐싱 또는 조각 캐싱을 사용하도록 응용 프로그램을 디자인 및 구성하여 처리 부하를 최소화합니다.
- **클라이언트 쪽 캐싱 사용**. 웹 응용 프로그램은 캐시 가능한 콘텐츠에 대해 캐시 설정을 사용해야 합니다. 일반적으로 이 기능은 기본적으로 사용하지 않도록 설정됩니다. 프록시 서버 및 클라이언트에서 콘텐츠를 캐시할 수 있게 적절한 캐시 제어 헤더를 제공하도록 서버를 구성합니다.
- **Azure Blob 저장소 및 CDN을 사용하여 응용 프로그램 부하 감소**. 이미지, 리소스, 스크립트, 스타일 시트 등 정적이거나 비교적 정적인 공용 콘텐츠를 Blob 저장소에 저장하는 것이 좋습니다. 이 접근 방식은 각 요청에 대해 이러한 콘텐츠를 동적으로 생성함에 따라 발생하는 응용 프로그램 부하를 줄여 줍니다. 또한 CDN을 사용하여 이 콘텐츠를 캐시하고 클라이언트에 배달하는 것이 좋습니다. CDN을 사용하면 콘텐츠가 CDN 캐시를 포함하는 지리적으로 가장 가까운 데이터 센터에서 배달되기 때문에 클라이언트의 성능이 향상됩니다. 자세한 내용은 [CDN 지침](best-practices-cdn.md)을 참조하세요.

- **SQL 쿼리 및 인덱스 최적화 및 튜닝**. 일부 T-SQL 문 또는 구문은 성능에 영향을 줄 수 있으며, 이러한 영향은 저장 프로시저의 코드를 최적화하여 줄일 수 있습니다. 예를 들어 **datetime** 리터럴 값과 비교하기 전에 **datetime** 형식을 **varchar**로 변환해서는 안 됩니다. 대신 date/time 비교 함수를 사용합니다. 적절한 인덱스가 없으면 쿼리 실행 속도가 느려질 수 있습니다. ORM(개체/관계형 매핑) 프레임워크를 사용하는 경우 작동 방식 및 데이터 액세스 계층의 성능에 영향을 줄 수 있는 방식을 이해해야 합니다. 자세한 내용은 [쿼리 튜닝](https://technet.microsoft.com/library/ms176005.aspx)을 참조하세요.
- **데이터 비정규화**. 데이터 정규화는 중복 및 불일치를 방지하는 데 도움이 됩니다. 그러나 여러 인덱스를 유지 관리하고, 참조 무결성을 확인하고, 소량의 데이터에 여러 번 액세스하고, 테이블을 조인하여 데이터를 다시 어셈블해야 하기 때문에 성능에 영향을 줄 수 있는 오버헤드가 발생합니다. 데이터 저장소의 부하를 줄이기 위해 일부 추가 저장소 볼륨 및 중복을 허용할지 고려하세요. 또한 데이터 저장소의 부하를 줄이기 위해 참조 무결성 관리와 같은 작업을 응용 프로그램 자체(일반적으로 확장이 보다 간편함)에서 수행할 수 있는지 고려하세요. 자세한 내용은 [데이터 분할 지침](https://github.com/mspnp/azure-guidance/blob/master/Data%20partitioning.md)을 참조하세요.

## 서비스 구현
- **비동기 호출 사용**. 호출 스레드 잠금을 방지하기 위하여 가능한 경우 I/O 또는 네트워크 대역폭으로 제한될 수 있거나 대기 시간이 긴 리소스 또는 서비스에 액세스할 때 비동기 코드를 사용합니다. 작업 기반 비동기 패턴을 사용하여 비동기 작업을 구현할 수 있습니다. 자세한 내용은 Microsoft 웹 사이트에서 [TAP(작업 기반 비동기 패턴)](https://msdn.microsoft.com/library/hh873175.aspx) 페이지를 참조하세요.
- **리소스 잠금을 방지하고, 대신 낙관적 접근 방식 사용**. 저장소 또는 대기 시간이 긴 기타 서비스와 같은 리소스에 대한 액세스를 잠그면 안 됩니다. 이는 성능 저하의 주요 원인입니다. 항상 낙관적 접근 방법을 사용하여 저장소에 쓰기와 같은 동시 작업을 관리하고, 저장소 계층 기능을 사용하여 충돌을 관리하세요. 분산된 응용 프로그램에서는 데이터의 일관성이 결과적으로만 유지될 수 있습니다.
- **대기 시간이 높고 대역폭이 낮은 네트워크를 통해 압축성이 뛰어난 데이터 압축**. 웹 응용 프로그램의 경우 대부분 응용 프로그램에 의해 생성되고 네트워크를 통해 전달되는 데이터는 클라이언트 요청에 대한 HTTP 응답입니다. HTTP 압축은 특히 정적 콘텐츠의 경우 이러한 데이터를 크게 줄일 수 있습니다. 따라서 비용이 절감되고 네트워크 부하가 감소할 수 있습니다. 다만, 동적 콘텐츠 압축은 서버에 부분적으로 더 높은 부하를 적용합니다. 보다 일반적인 다른 환경에서는 데이터 압축을 통해 전송되는 데이터 양을 줄임으로써 전송 시간 비용을 최소화할 수 있지만 압축 및 압축 해제 프로세스는 오버헤드를 발생시킵니다. 따라서 압축은 성능에 명확히 유익한 경우에만 사용해야 합니다. JSON 또는 이진 인코딩과 같은 다른 직렬화 메서드는 성능에 대한 영향 없이 페이로드 크기를 줄일 수 있는 반면, XML은 이를 증가시킬 수 있습니다.
- **연결 및 리소스 사용 시간 최소화**. 사용해야 하는 시간 동안만 연결 및 리소스를 유지 관리합니다. 예를 들어 연결을 최대한 늦게 열고 최대한 빨리 연결 풀로 되돌아갈 수 있도록 합니다. 또한 리소스를 최대한 늦게 획득하고 최대한 빨리 삭제합니다.
- **필요한 연결 수 최소화**. 서비스 연결에는 리소스가 사용됩니다. 가능한 경우 필요한 수를 제한하고 가급적 기존 연결을 다시 사용할 수 있도록 합니다. 예를 들어 인증을 수행한 후에는 적절한 경우 가장을 사용하여 코드를 특정 ID로 실행합니다. 이렇게 하면 연결을 다시 사용하여 연결 풀 사용을 최적화할 수 있습니다. 

	> [AZURE.NOTE]
- **요청을 일괄 처리로 보내 네트워크 사용 최적화**. 예를 들어 큐에 액세스할 때 메시지를 일괄 처리로 보내고 읽고, 저장소 또는 캐시에 액세스할 때 여러 읽기 또는 쓰기를 일괄 처리로 수행합니다. 이렇게 하면 네트워크를 통한 호출 수를 줄여 서비스 및 데이터 저장소의 효율성을 최대화시키는데 도움이 됩니다.
- **가능한 경우 서버 쪽 세션 상태에 대한 요구 사항 방지**. 서버 쪽 세션 상태를 관리하려면 일반적으로 클라이언트 선호도(즉, 각 요청을 동일한 서버 인스턴스로 라우팅)가 필요하며, 이는 시스템 확장성에 영향을 줍니다. 클라이언트를 사용하는 서버에 대해 상태를 저장하지 않도록 클라이언트를 디자인하는 것이 가장 좋습니다. 그러나 응용 프로그램에서 세션 상태를 유지해야 하는 경우에는 중요한 데이터 또는 대량의 클라이언트별 데이터를 응용 프로그램의 모든 인스턴스에서 액세스할 수 있는 분산된 서버 쪽 캐시에 저장하세요.
- **테이블 저장소 스키마 최적화**. 테이블 및 열 이름을 모든 쿼리와 함께 전달하고 처리해야 하는 테이블 저장소(예: Azure 테이블 저장소)를 사용하는 경우 짧은 이름을 사용하여 이 오버헤드를 줄이는 것이 좋습니다. 그러나 쉽게 알 수 없는 간결한 이름을 사용하여 가독성 및 관리 효율성이 저하되지 않도록 해야 합니다.
- **TPL을 활용하여 비동기 작업 수행**. TPL(작업 병렬 라이브러리)을 사용하면 I/O 바인딩된 작업을 수행하는 비동기 코드를 쉽게 작성할 수 있습니다. 가능한 경우 _ConfigureAwait(false)_를 사용하여 특정 동기화 컨텍스트에서 연속 종속성을 제거하고 스레드 교착 상태가 발생할 확률을 줄이세요.
- **배포 중 또는 응용 프로그램 시작 시 리소스 종속성 만들기**. 리소스 존재 여부를 테스트한 다음, 없는 경우 리소스를 만드는 메서드(Azure 저장소 클라이언트 라이브러리의 _CloudTable.CreateIfNotExists_ 및 _CloudQueue.CreateIfNotExists_와 같은 메서드가 이 패턴을 따름)에 대한 반복적인 호출을 방지합니다. 저장소 테이블 또는 저장소 큐에 액세스할 때마다 이러한 메서드가 사전에 호출되면 상당한 오버헤드가 발생할 수 있습니다. 대신, 응용 프로그램을 배포하거나 처음 시작할 때 필요한 리소스를 만듭니다(웹 또는 작업자 역할의 시작 코드에 대한 응답마다 _CreateIfNotExists_에 대한 단일 호출만 허용됨). 그러나 코드에서 존재하지 않는 리소스에 대한 액세스를 시도하는 경우에 발생할 수 있는 예외를 처리해야 합니다. 이러한 경우는 예외를 기록하고 리소스가 누락되었음을 작업자에게 경고해야 합니다. 경우에 따라 예외 처리 코드의 일부로 누락된 리소스를 만드는 것이 적절할 수 있지만, 리소스가 없는 것이 프로그래밍 오류(예: 철자가 잘못된 리소스 이름) 또는 다른 인프라 수준의 문제를 나타낼 수 있으므로 주의해야 합니다.
- **경량 프레임워크 사용**. 리소스 사용, 실행 시간 및 응용 프로그램의 전체 부하를 최소화하려면 사용할 API 및 프레임워크를 신중히 선택해야 합니다. 예를 들어 Web API를 사용하여 서비스 요청을 처리하면 응용 프로그램 설치 공간을 줄이고 실행 속도를 높일 수 있지만 WCF의 추가 기능이 필요한 고급 시나리오에는 적합하지 않을 수 있습니다.
- **서비스 계정 수 최소화**. 예를 들어 연결을 제한하거나 유지 관리되는 연결 수가 적을수록 성능이 뛰어난 리소스 또는 서비스에 액세스할 경우 특정 계정을 사용합니다. 이 접근 방법은 데이터베이스와 같은 서비스에 일반적이지만, 원래 사용자의 가장으로 인해 작업을 정확하게 감사하는 기능에 영향을 줄 수 있습니다.
- **성능 프로파일링 및 부하 테스트 수행** 배포 중, 테스트 루틴 과정, 최종 릴리스 전에 수행하여 응용 프로그램이 정상적으로 실행되고 필요에 따라 확장되도록 합니다. 이 테스트는 데이터 및 사용자 부하의 유형 및 양이 프로덕션에서 발생하는 것과 동일한 상태에서 프로덕션 플랫폼과 동일한 유형의 하드웨어에서 수행되어야 합니다. 자세한 내용은 Microsoft 웹 사이트에서 [클라우드 서비스의 성능 테스트](https://msdn.microsoft.com/library/azure/hh369930.aspx) 페이지를 참조하세요.

<!---HONumber=July15_HO5-->