---
title: 크기 조정 및 성능을 지원하도록 Azure Cosmos DB 테이블 설계
description: 'Azure Storage 테이블 설계 가이드: Azure Cosmos DB 및 Azure Storage 테이블에 확장성 있는 고성능 테이블 설계'
ms.service: cosmos-db
ms.subservice: cosmosdb-table
ms.topic: conceptual
ms.date: 12/07/2018
author: wmengmsft
ms.author: wmeng
ms.custom: seodec18
ms.openlocfilehash: 84749332c5b7ab5fec2905c0fc36d89863adc3d2
ms.sourcegitcommit: 3102f886aa962842303c8753fe8fa5324a52834a
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/23/2019
ms.locfileid: "60579646"
---
# <a name="azure-storage-table-design-guide-designing-scalable-and-performant-tables"></a>Azure Storage 테이블 설계 가이드: 확장성 있는 고성능 테이블 설계

[!INCLUDE [storage-table-cosmos-db-tip-include](../../includes/storage-table-cosmos-db-tip-include.md)]

확장형 및 영구 테이블을 디자인하려면 성능, 확장성, 비용 등 여러 가지 요소를 고려해야 합니다. 이전에 관계형 데이터베이스의 스키마를 디자인해 본 적이 있는 경우 이러한 고려 사항에 익숙하겠지만 Azure Table service 저장소 모델과 관계형 모델 간에는 일부 유사한 점이 있는 반면 중요한 차이점도 많이 있습니다. 이러한 차이점으로 인해 일반적으로 관계형 데이터베이스에 익숙한 사용자에게는 직관에 반하거나 잘못된 것으로 보일 수 있지만 Azure Table service와 같은 NoSQL 키/값 저장소를 디자인하는 경우에는 매우 적절한 다른 디자인이 도출됩니다. 디자인 차이점의 대부분은 Table service는 수십억 개의 데이터 엔터티(관계 데이터베이스 용어로는 행)를 포함할 수 있거나 대용량 트랜잭션을 지원해야 하는 데이터 집합에 사용되는 클라우드 규모의 애플리케이션을 지원하도록 디자인된다는 사실을 반영합니다. 따라서 데이터를 저장하는 방법을 다르게 생각하고 Table service의 작동 방식을 이해해야 합니다. 잘 디자인된 NoSQL 데이터 저장소는 관계형 데이터베이스를 사용하는 솔루션보다 적은 비용으로 훨씬 뛰어난 확장성을 제공할 수 있습니다. 이 가이드에서는 이러한 항목에 대해 설명합니다.  

## <a name="about-the-azure-table-service"></a>Azure Table service 정보
이 섹션에서는 특히 성능 및 확장성 디자인과 관련이 있는 Table service의 몇 가지 주요 기능을 중점적으로 살펴봅니다. Azure Storage와 Table service를 처음 접하는 경우 이 문서의 나머지 내용을 진행하기 전에 먼저 [Microsoft Azure Storage 소개](../storage/common/storage-introduction.md) 및 [.NET을 사용하여 Azure Table Storage 시작](table-storage-how-to-use-dotnet.md)을 읽어 보시기 바랍니다. 이 가이드는 Table service에 중점을 두지만 Azure 큐 및 Blob service를 소개하고 솔루션에서 Table service와 함께 이를 사용할 수 있는 방법에 대해서도 다룹니다.  

Table service란? 이름에서 알 수 있듯이, Table service에서는 테이블 형식을 사용하여 데이터를 저장합니다. 표준 용어로, 테이블의 각 행은 엔터티를 나타내고 행은 해당 엔터티의 여러 속성을 저장합니다. 모든 엔터티에는 해당 엔터티를 고유하게 식별하는 키 쌍과 Table service에서 엔터티가 마지막으로 업데이트된 시점을 추적(타임스탬프 필드가 자동으로 추가되며, 타임스탬프를 임의의 값으로 수동으로 덮어쓸 수 없음)하는 데 사용하는 타임스탬프 열이 있습니다. Table service에서는 LMT(마지막 수정 타임스탬프)를 사용하여 낙관적 동시성을 관리합니다.  

> [!NOTE]
> 또한 Table service REST API 작업은 LMT(마지막 수정 타임스탬프)에서 파생되는 **ETag** 값을 반환합니다. 이 문서에서는 ETag와 LMT를 상호 교환적으로 사용합니다. 이러한 용어는 동일한 기본 데이터를 의미하기 때문입니다.  
> 
> 

다음 예제에서는 직원 및 부서 엔터티를 저장하는 간단한 테이블 디자인을 보여 줍니다. 이 가이드의 뒷부분에 나오는 예제는 대부분 이 간단한 디자인을 기반으로 합니다.  

<table>
<tr>
<th>PartitionKey</th>
<th>RowKey</th>
<th>타임 스탬프</th>
<th></th>
</tr>
<tr>
<td>Marketing</td>
<td>00001</td>
<td>2014-08-22T00:50:32Z</td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>Email</th>
</tr>
<tr>
<td>Don</td>
<td>Hall</td>
<td>34</td>
<td>donh@contoso.com</td>
</tr>
</table>
</tr>
<tr>
<td>Marketing</td>
<td>00002</td>
<td>2014-08-22T00:50:34Z</td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>Email</th>
</tr>
<tr>
<td>Jun</td>
<td>Cao</td>
<td>47</td>
<td>junc@contoso.com</td>
</tr>
</table>
</tr>
<tr>
<td>Marketing</td>
<td>department</td>
<td>2014-08-22T00:50:30Z</td>
<td>
<table>
<tr>
<th>DepartmentName</th>
<th>EmployeeCount</th>
</tr>
<tr>
<td>Marketing</td>
<td>153</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>Sales</td>
<td>00010</td>
<td>2014-08-22T00:50:44Z</td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>Email</th>
</tr>
<tr>
<td>Ken</td>
<td>Kwok</td>
<td>23</td>
<td>kenk@contoso.com</td>
</tr>
</table>
</td>
</tr>
</table>


지금까지는 이 디자인은 필수 열이 있고 여러 엔터티 형식을 동일한 테이블에 저장할 수 있다는 점을 제외하고는 관계형 데이터베이스의 테이블과 비슷하게 보입니다. 또한 **FirstName** 또는 **Age**와 같은 각 사용자 정의 속성에 관계형 데이터베이스의 열과 마찬가지로 정수 또는 문자열과 같은 데이터 형식이 있습니다. 관계형 데이터베이스와 달리 Table service는 스키마 없음 속성을 갖추고 있기 때문에 각 엔터티의 데이터 유형이 동일하지 않아도 됩니다. 복잡한 데이터 형식을 단일 속성에 저장하려면 JSON 또는 XML과 같은 직렬화된 형식을 사용해야 합니다. 지원되는 데이터 형식, 지원되는 날짜 범위, 명명 규칙, 크기 제약 조건 등 테이블 서비스에 대한 자세한 내용은 [테이블 서비스 데이터 모델 이해](https://msdn.microsoft.com/library/azure/dd179338.aspx)를 참조하세요.

**PartitionKey** 및 **RowKey** 선택은 적절한 테이블 디자인의 기본 사항입니다. 테이블에 저장된 모든 엔터티에는 고유하게 조합된 **PartitionKey**와 **RowKey**가 있어야 합니다. 관계형 데이터베이스의 키와 마찬가지로 **PartitionKey** 및 **RowKey** 값은 빠른 조회를 지원하는 클러스터형 인덱스를 생성하기 위해 인덱싱됩니다. 그러나 Table service에서는 보조 인덱스를 만들지 않으므로 인덱싱된 속성은 이 두 개뿐입니다(이 명확한 제한 사항을 해결하는 방법은 뒷부분에 설명된 일부 패턴 참조).  

테이블은 하나 이상의 파티션으로 구성되므로 디자인 의사 결정은 대부분 적절한 **PartitionKey** 및 **RowKey**를 선택하여 솔루션을 최적화하는 데 중점을 둡니다. 솔루션은 파티션으로 구성된 모든 엔터티를 포함하는 단일 테이블로 구성될 수 있지만 일반적으로 솔루션에는 여러 테이블이 있습니다. 테이블을 사용하면 엔터티를 논리적으로 구성하고, 액세스 제어 목록을 사용하여 데이터 액세스를 보다 쉽게 관리하며, 단일 저장소 작업을 사용하여 전체 테이블을 삭제할 수 있습니다.  

### <a name="table-partitions"></a>테이블 파티션
계정 이름, 테이블 이름 및 **PartitionKey**는 Table service가 엔터티를 저장하는 저장소 서비스 내에서 파티션을 식별합니다. 파티션은 엔터티의 주소 지정 체계의 일부일 뿐만 아니라 트랜잭션의 범위를 정의(아래의 [EGT(엔터티 그룹 트랜잭션)](#entity-group-transactions) 참조)하며, 테이블 서비스를 확장하는 방법의 기초가 됩니다. 파티션에 대한 자세한 내용은 [Azure Storage 확장성 및 성능 목표](../storage/common/storage-scalability-targets.md)를 참조하세요.  

Table service에서 개별 노드는 하나 이상의 전체 파티션을 지원하며, 서비스는 노드 간에 파티션 부하를 동적으로 분산하여 크기가 조정됩니다. 하나의 노드에 부하가 걸려 있는 경우 Table service는 해당 노드가 지원하는 파티션 범위를 여러 노드로 *분할*할 수 있습니다. 트래픽이 진정되면 서비스는 안정된 노드의 파티션 범위를 단일 노드로 다시*병합*할 수 있습니다.  

Table service의 내부 세부 정보, 특히 서비스에서 파티션을 관리하는 방법에 대한 자세한 내용은 [Microsoft Azure Storage: 강력한 일관성과 함께 항상 사용 가능한 클라우드 스토리지 서비스](https://blogs.msdn.com/b/windowsazurestorage/archive/2011/11/20/windows-azure-storage-a-highly-available-cloud-storage-service-with-strong-consistency.aspx) 문서를 참조하세요.  

### <a name="entity-group-transactions"></a>EGT(엔터티 그룹 트랜잭션)
Table service에서 EGT(엔터티 그룹 트랜잭션)는 여러 엔터티 간에 원자성 업데이트를 수행하기 위한 유일한 기본 제공 메커니즘입니다. EGT를 일부 문서에서는 *일괄 처리 트랜잭션* 이라고도 합니다. EGT는 동일한 파티션(지정된 테이블에서 동일한 파티션 키 공유)에 저장된 엔터티에서만 작동할 수 있으므로 여러 엔터티에서 원자성 트랜잭션 동작이 필요한 경우 해당 엔터티가 동일한 파티션에 있는지 확인해야 합니다. 따라서 서로 다른 엔터티 유형에 여러 테이블을 사용하지 말고 여러 엔터티 유형을 동일한 테이블(및 파티션)에 유지하는 것이 좋습니다. 단일 EGT는 최대 100개의 엔터티에서 작동할 수 있습니다.  처리를 위해 여러 개의 동시에 발생하는 EGT를 제출하는 경우에 이러한 EGT가 EGT 간에 공통된 엔터티에서 작동되면 처리가 지연될 수 있으므로 그렇지 않도록 주의해야 합니다.

EGT는 디자인에서 평가할 잠재적 장단점이 있습니다. 사용하는 파티션이 많으면 Azure에서 노드 간에 요청을 부하 분산할 기회가 많기 때문에 애플리케이션의 확장성이 증가하지만 애플리케이션이 원자성 트랜잭션을 수행하고 데이터에 대한 강력한 일관성을 유지 관리할 수 있는 능력이 제한됩니다. 또한 파티션 수준에는 단일 노드에서 기대할 수 있는 트랜잭션 처리량을 제한하는 특정 확장성 목표가 있습니다. Azure Storage 계정 및 Table service의 확장성 목표에 대한 자세한 내용은 [Azure Storage 확장성 및 성능 목표](../storage/common/storage-scalability-targets.md)를 참조하세요. 이 가이드의 뒷부분에 나오는 섹션에서는 이와 같은 장단점을 관리하는 데 도움이 되는 여러 가지 디자인 전략을 소개하고, 클라이언트 애플리케이션의 특정 요구 사항에 따라 파티션 키를 선택하는 최상의 방법을 설명합니다.  

### <a name="capacity-considerations"></a>용량 고려 사항
다음 표에는 Table service 솔루션을 디자인할 때 알아야 할 몇 가지 키 값이 나와 있습니다.  

| Azure 저장소 계정의 총 용량 | 500TB |
| --- | --- |
| Azure 저장소 계정에서 테이블의 수 |저장소 계정의 용량에 의해서만 제한됨 |
| 테이블에 있는 파티션 수 |저장소 계정의 용량에 의해서만 제한됨 |
| 파티션의 엔터티 수 |저장소 계정의 용량에 의해서만 제한됨 |
| 개별 엔터티의 크기 |최대 255개 속성을 포함하여 최대 1MB(**PartitionKey**, **RowKey** 및 **타임스탬프** 포함) |
| **PartitionKey** |최대 1KB의 크기 문자열 |
| **RowKey** |최대 1KB의 크기 문자열 |
| 엔터티 그룹 트랜잭션의 크기 |한 개 트랜잭션에는 최대 100개의 엔터티가 포함될 수 있고, 페이로드 크기는 4MB 미만이어야 합니다. EGT는 한 번에 하나의 엔터티만 업데이트할 수 있음 |

자세한 내용은 [테이블 서비스 데이터 모델 이해](https://msdn.microsoft.com/library/azure/dd179338.aspx)를 참조하세요.  

### <a name="cost-considerations"></a>비용 고려 사항
Table Storage는 비교적 저렴하지만 Table service를 사용하는 솔루션을 평가할 때 용량 사용과 트랜잭션 양 둘 다에 대한 예상 비용을 포함해야 합니다. 그러나 대부분의 시나리오에서는 비정규화되거나 중복된 데이터를 저장하여 솔루션의 성능 또는 확장성을 개선하는 것이 유효한 접근 방식입니다. 가격 책정에 대한 자세한 내용은 [Azure Storage 가격 책정](https://azure.microsoft.com/pricing/details/storage/)을 참조하세요.  

## <a name="guidelines-for-table-design"></a>테이블 디자인 지침
이 목록은 사용자의 테이블을 디자인할 때 염두에 두어야 하는 몇 가지 핵심 지침을 요약하고 이 가이드 뒷부분에서 자세히 설명합니다. 이러한 지침은 일반적으로 관계형 데이터베이스 디자인을 수행하는 지침과 다릅니다.  

효율적으로 *읽을* 수 있도록 Table service 솔루션 디자인:

* ***읽기 작업이 많은 애플리케이션의 쿼리를 위해 디자인합니다.*** 테이블을 디자인할 때는 엔터티 업데이트 방법을 고려하기 전에 먼저 쿼리(특히 대기 시간이 중요한 쿼리)를 고려해야 합니다. 이는 일반적으로 솔루션의 효율성 및 성능에 영향을 줍니다.  
* ***쿼리에서 PartitionKey와 RowKey 둘 다 지정합니다.*** *지점 쿼리* 는 가장 효율적인 테이블 서비스 쿼리입니다.  
* ***엔터티의 중복 복사본을 저장하는 것이 좋습니다.*** Table Storage는 저렴하므로 여러 번 저장(다른 키를 사용하여)하여 쿼리의 효율성을 높이는 것이 좋습니다.  
* ***데이터를 비정규화하는 것이 좋습니다.*** Table Storage는 저렴하기 때문에 데이터를 비정규화하는 것이 좋습니다. 예를 들어 집계 데이터에 대한 쿼리에서 단일 엔터티에만 액세스하면 되도록 요약 엔터티를 저장합니다.  
* ***복합 키 값을 사용하는 것이 좋습니다.*** 사용하는 키는 **PartitionKey**와 **RowKey**뿐입니다. 예를 들어 복합 키 값을 사용하여 엔터티에 대한 대체 키 액세스 경로를 사용하도록 설정할 수 있습니다.  
* ***쿼리 프로젝션을 사용합니다.*** 필요한 필드만 선택하는 쿼리를 사용하여 네트워크를 통해 전송하는 데이터 양을 줄일 수 있습니다.  

효율적으로 *쓸* 수 있도록 Table service 솔루션을 디자인합니다.  

* ***핫 파티션을 만들지 마세요.*** 언제든 여러 파티션으로 요청을 분산할 수 있는 키를 선택합니다.  
* ***트래픽 급증을 방지합니다.*** 적절한 기간에 걸쳐 트래픽을 원활하게 유지하고 트래픽 급증을 방지합니다.
* ***각 엔터티 유형에 대한 별도의 테이블을 만들 필요가 없습니다.*** 엔터티 유형 간에 원자성 트랜잭션이 필요한 경우 이러한 여러 엔터티 유형을 동일한 테이블의 동일한 파티션에 저장할 수 있습니다.
* ***달성해야 하는 최대 처리량을 고려합니다.*** Table service의 확장성 목표를 알고 디자인으로 인해 이러한 목표가 초과되지 않도록 해야 합니다.  

이 가이드에서는 이 모든 원칙을 실습해 볼 수 있는 예제를 제공합니다.  

## <a name="design-for-querying"></a>쿼리를 위한 디자인
Table service 솔루션은 읽기 집중적이거나, 쓰기 집중적이거나, 이 두 가지가 혼합되어 있을 수 있습니다. 이 섹션에서는 읽기 작업을 효율적으로 지원하는 Table service를 디자인할 때 알아야 할 사항에 중점을 둡니다. 일반적으로 읽기 작업을 효율적으로 지원하는 디자인은 쓰기 작업에도 효율적입니다. 그러나 쓰기 작업을 지원하도록 디자인할 때 염두에 두어야 하는 추가적인 고려 사항이 있습니다(다음에 나오는 [데이터 수정을 위한 디자인](#design-for-data-modification)섹션 참조).

데이터를 효율적으로 읽을 수 있도록 Table service 솔루션을 디자인하려면 "애플리케이션이 Table service에서 필요한 데이터를 검색하기 위해 실행해야 하는 쿼리는 무엇인가?"라는 질문에서 출발하는 것이 좋습니다.  

> [!NOTE]
> Table service에서는 사전에 올바르게 디자인하는 것이 중요합니다. 나중에 변경하려면 작업이 어렵고 비용이 많이 들기 때문입니다. 예를 들어 관계형 데이터베이스에서는 기존 데이터베이스에 인덱스를 추가하는 것만으로 성능 문제를 해결할 수 있는 경우가 종종 있습니다. 하지만 Table service에서는 그럴 수 없습니다.  
> 
> 

이 섹션에서는 쿼리를 위한 테이블을 디자인할 때 해결해야 하는 주요 문제를 중점적으로 알아봅니다. 이 섹션에서 다루는 항목은 다음과 같습니다.

* [PartitionKey 및 RowKey 선택이 쿼리 성능에 미치는 영향](#how-your-choice-of-partitionkey-and-rowkey-impacts-query-performance)
* [적절한 PartitionKey 선택](#choosing-an-appropriate-partitionkey)
* [Table service에 대한 쿼리 최적화](#optimizing-queries-for-the-table-service)
* [Table service에서 데이터 정렬](#sorting-data-in-the-table-service)

### <a name="how-your-choice-of-partitionkey-and-rowkey-impacts-query-performance"></a>PartitionKey 및 RowKey 선택이 쿼리 성능에 미치는 영향
다음 예제에서는 테이블 서비스가 다음과 같은 구조로 직원 엔터티를 저장하는 것으로 가정합니다(대부분의 예제에 명확성을 위해 **Timestamp** 속성이 생략되어 있음).  

| *열 이름* | *데이터 형식* |
| --- | --- |
| **PartitionKey** (부서 이름) |문자열 |
| **RowKey** (직원 Id) |문자열 |
| **FirstName** |문자열 |
| **LastName** |문자열 |
| **Age** |정수  |
| **EmailAddress** |문자열 |

이전 섹션 Azure Table service 개요에서는 쿼리를 위한 디자인에 직접적인 영향을 미치는 Azure Table service의 주요 기능에 대해 설명했습니다. 이 섹션의 내용은 Table service 쿼리 디자인에 대한 다음과 같은 일반적인 지침으로 요약됩니다. 아래 예제에 사용된 필터 구문은 Table service REST API에서 가져온 것입니다(자세한 내용은 [엔터티 쿼리](https://msdn.microsoft.com/library/azure/dd179421.aspx)참조).  

* ***지점 쿼리***는 가장 효율적인 조회 방법이며, 대용량 조회 또는 가장 낮은 대기 시간이 필요한 조회에 사용하는 것이 좋습니다. 이러한 쿼리에서는 인덱스를 사용해 **PartitionKey** 및 **RowKey** 값을 지정하여 개별 엔터티를 효율적으로 찾을 수 있습니다. 예: $filter=(PartitionKey eq 'Sales') and (RowKey eq '2')  
* 두 번째로 좋은 방법은 **PartitionKey**를 사용하고 **RowKey** 값 범위를 필터링하여 둘 이상의 엔터티를 반환하는 ***Range Query***입니다. **PartitionKey** 값은 특정 파티션을 식별하고, **RowKey** 값은 해당 파티션에 있는 엔터티의 하위 집합을 식별합니다. 예: $filter=PartitionKey eq 'Sales' and RowKey ge 'S' and RowKey lt 'T'  
* 세 번째로 좋은 방법은 **PartitionKey**를 사용하고 키가 아닌 다른 속성을 필터링하여 둘 이상의 엔터티를 반환하는 ***파티션 검색***입니다. **PartitionKey** 값은 특정 파티션을 식별하고, 속성 값은 해당 파티션에 있는 엔터티의 하위 집합에 대해 선택됩니다. 예: $filter=PartitionKey eq 'Sales' and LastName eq 'Smith'  
* ***테이블 검색***은 **PartitionKey**를 포함하지 않으며, 테이블을 구성하는 모든 파티션에서 일치하는 모든 엔터티를 검색하기 때문에 비효율적입니다. 필터에서 **RowKey**를 사용하는지 여부에 상관없이 테이블 검색을 수행합니다. 예: $filter=LastName eq 'Jones'  
* 여러 엔터티를 반환하는 Azure Table Storage 쿼리는 **PartitionKey**와 **RowKey** 순으로 정렬된 엔터티를 반환합니다. 클라이언트에서 엔터티 재정렬을 방지하려면 가장 일반적인 정렬 순서를 정의하는 **RowKey**를 선택합니다. 파티션 키 또는 행 키로 Azure Cosmos DB에서 Azure Table API에서 반환한 쿼리 결과 정렬 되지 않습니다. 자세한 기능 차이 목록에 대해서는 [Azure Cosmos DB 및 Azure Table Storage의 Table API 간 차이점](faq.md#where-is-table-api-not-identical-with-azure-table-storage-behavior)을 참조하세요.

"**or**"을 사용하여 **RowKey** 값을 기반으로 필터를 지정하면 범위 쿼리로 처리되는 것이 아니라 파티션 검색이 수행됩니다. 따라서 다음과 같은 필터를 사용하는 쿼리는 피해야 합니다. $filter=PartitionKey eq 'Sales' and (RowKey eq '121' or RowKey eq '322')  

Storage 클라이언트 라이브러리를 사용하여 효율적인 쿼리를 실행하는 클라이언트 쪽 코드의 예는 다음을 참조하세요.  

* [Storage 클라이언트 라이브러리를 사용하여 지점 쿼리 실행](#executing-a-point-query-using-the-storage-client-library)
* [LINQ를 사용하여 여러 엔터티 검색](#retrieving-multiple-entities-using-linq)
* [서버 쪽 프로젝션](#server-side-projection)  

동일한 테이블에 저장된 여러 엔터티 유형을 처리할 수 있는 클라이언트 쪽 코드의 예는 다음을 참조하세요.  

* [유형이 다른 엔터티 유형 작업](#working-with-heterogeneous-entity-types)  

### <a name="choosing-an-appropriate-partitionkey"></a>적절한 PartitionKey 선택
**PartitionKey**를 선택할 때는 EGT 사용에 대한 요구 사항(일관성 유지)과 여러 파티션에 엔터티를 분산하는 데 대한 요구 사항(솔루션의 확장성 향상) 간에 균형을 유지해야 합니다.  

한 쪽으로 치우치면 모든 엔터티를 단일 파티션에 저장할 수 있지만 솔루션의 확장성이 제한되어 테이블 서비스에서 요청 부하를 분산하지 못할 수 있습니다. 다른 쪽으로 치우치면 파티션당 하나의 엔터티를 저장하여 확장성을 높이고 테이블 서비스에서 요청 부하를 분산할 수 있지만 엔터티 그룹 트랜잭션을 사용하지 못합니다.  

이상적인 **PartitionKey** 는 효율적인 쿼리를 사용할 수 있도록 하고 솔루션을 확장할 수 있는 충분한 파티션이 있는 키입니다. 일반적으로 엔터티에는 충분한 파티션으로 엔터티를 분산하는 적절한 속성이 있습니다.

> [!NOTE]
> 예를 들어 사용자 또는 직원에 대한 정보를 저장하는 시스템에서는 UserID가 적절한 PartitionKey일 수 있습니다. 지정된 UserID를 파티션 키로 사용하는 여러 엔터티가 있을 수 있습니다. 사용자에 대한 데이터를 저장하는 각 엔터티는 단일 파티션으로 그룹화되므로 이러한 엔터티는 높은 확장성을 유지하면서 엔터티 그룹 트랜잭션을 통해 액세스할 수 있습니다.
> 
> 

**PartitionKey**를 선택할 때 엔터티 삽입, 업데이트 및 삭제 방법과 관련된 추가 고려 사항이 있습니다. 자세한 내용은 아래의 [데이터 수정을 위한 디자인](#design-for-data-modification)을 참조하세요.  

### <a name="optimizing-queries-for-the-table-service"></a>Table service에 대한 쿼리 최적화
Table service는 단일 클러스터형 인덱스의 **PartitionKey** 및 **RowKey** 값을 사용하여 엔터티를 자동으로 인덱싱하기 때문에 지점 쿼리가 가장 효율적입니다. 그러나 **PartitionKey** 및 **RowKey**에는 클러스터형 인덱스에 있는 인덱스만 있습니다.

대부분의 디자인은 여러 조건을 기반으로 엔터티를 조회할 수 있어야 한다는 요구 사항을 준수해야 합니다. 예를 들어 전자 메일, 직원 ID 또는 성을 기반으로 직원 엔터티를 찾을 수 있어야 합니다. [테이블 디자인 패턴](#table-design-patterns) 섹션에 있는 다음 패턴은 이러한 유형의 요구 사항을 다루며, Table service에서 보조 인덱스를 제공하지 않는 부분을 해결하는 방법을 설명합니다.  

* [파티션 간 보조 인덱스 패턴](#intra-partition-secondary-index-pattern) - 서로 다른 **RowKey** 값을 사용하여 각 엔터티의 여러 복사본을 동일한 파티션에 저장하여 빠르고 효율적인 조회를 지원하며, 서로 다른 **RowKey** 값을 사용하여 대체 정렬 순서를 허용합니다.  
* [파티션 간 보조 인덱스 패턴](#inter-partition-secondary-index-pattern) - 서로 다른 **RowKey** 값을 사용하여 각 엔터티의 여러 복사본을 별도의 파티션과 별도의 테이블에 저장하여 빠르고 효율적인 조회를 지원하며, 서로 다른 **RowKey** 값을 사용하여 대체 정렬 순서를 허용합니다.  
* [인덱스 엔터티 패턴](#index-entities-pattern) - 인덱스 엔터티를 유지 관리하여 엔터티 목록을 반환하는 효율적인 검색을 지원합니다.  

### <a name="sorting-data-in-the-table-service"></a>Table service에서 데이터 정렬

Table service에서 반환되는 쿼리 결과는 **PartitionKey**를 기준으로 오름차순으로 정렬된 다음, **RowKey**를 기준으로 정렬됩니다.

> [!NOTE]
> 파티션 키 또는 행 키로 Azure DB에서 Azure Table API에서 반환한 쿼리 결과 정렬 되지 않습니다. 자세한 기능 차이 목록에 대해서는 [Azure Cosmos DB 및 Azure Table Storage의 Table API 간 차이점](faq.md#where-is-table-api-not-identical-with-azure-table-storage-behavior)을 참조하세요.

Azure Storage 테이블의 키는 문자열 값이며, 숫자 값이 올바르게 정렬되도록 하려면 이를 고정 길이로 변환하고 0으로 채워야 합니다. 예를 들어 **RowKey**로 사용하는 직원 ID 값이 정수 값인 경우 직원 ID를 **123**에서 **00000123**으로 변환해야 합니다. 

많은 애플리케이션에서 서로 다른 순서로 정렬(예: 이름 또는 입사 날짜별로 직원 정렬)된 데이터를 사용할 수 있도록 요구하고 있습니다. 섹션에 있는 다음 [테이블 디자인 패턴](#table-design-patterns) 은 엔터티의 순서를 대체 정렬하는 방법을 다룹니다.  

* [파티션 간 보조 인덱스 패턴](#intra-partition-secondary-index-pattern) - 서로 다른 RowKey 값을 사용하여 각 엔터티의 여러 복사본을 동일한 파티션에 저장하여 빠르고 효율적인 조회를 지원하며, 서로 다른 RowKey 값을 사용하여 대체 정렬 순서를 허용합니다.  
* [파티션 간 보조 인덱스 패턴](#inter-partition-secondary-index-pattern) - 서로 다른 RowKey 값을 사용하여 각 엔터티의 여러 복사본을 별도의 파티션과 별도의 표에 저장하여 빠르고 효율적인 조회를 지원하며, 서로 다른 RowKey 값을 사용하여 대체 정렬 순서를 허용합니다.
* [로그 테일 패턴](#log-tail-pattern) - 날짜 및 시간 역순으로 정렬된 *RowKey* 값을 사용하여 가장 최근에 파티션에 추가된 **n** 엔터티를 검색합니다.  

## <a name="design-for-data-modification"></a>데이터 수정을 위한 디자인
이 섹션에서는 삽입, 업데이트 및 삭제를 최적화하기 위한 디자인 고려 사항을 중점적으로 알아봅니다. 관계형 데이터베이스의 디자인과 마찬가지로(관계형 데이터베이스의 경우 디자인 장단점을 관리하는 기술이 다름), 쿼리에 최적화된 디자인과 데이터 수정에 최적화된 디자인 간의 장단점을 평가해야 하는 경우가 있을 수 있습니다. [테이블 디자인 패턴](#table-design-patterns) 섹션은 Table service에 대한 몇 가지 자세한 디자인 패턴을 알아보고 이러한 패턴의 일부 장단점을 설명합니다. 실제로 엔터티 쿼리에 최적화된 디자인은 대부분 엔터티를 수정하는 데에도 효율적입니다.  

### <a name="optimizing-the-performance-of-insert-update-and-delete-operations"></a>삽입, 업데이트 및 삭제 작업 성능 최적화
엔터티를 업데이트하거나 삭제하려면 **PartitionKey** 및 **RowKey** 값을 사용하여 엔터티를 식별할 수 있어야 합니다. 이러한 점에서, 엔터티 수정을 위해 **PartitionKey** 및 **RowKey**를 선택할 때는 가급적 효율적으로 엔터티를 식별할 수 있어야 하므로 지점 쿼리를 지원하기 위해 선택한 것과 유사한 조건을 따라야 합니다. 업데이트하거나 삭제해야 하는 **PartitionKey** 및 **RowKey** 값을 찾기 위해 비효율적인 파티션 또는 테이블 검색을 사용하여 엔터티를 찾고 싶지는 않을 것입니다.  

[테이블 디자인 패턴](#table-design-patterns) 섹션의 다음 패턴은 성능 또는 삽입, 업데이트, 삭제 작업의 최적화를 다룹니다.  

* [대용량 삭제 패턴](#high-volume-delete-pattern) - 동시 삭제할 모든 엔터티를 고유한 별도의 테이블에 저장하여 대용량 엔터티 삭제를 지원합니다. 테이블을 삭제하면 엔터티가 삭제됩니다.  
* [데이터 계열 패턴](#data-series-pattern) - 전체 데이터 계열을 단일 엔터티에 저장하여 요청 수를 최소화합니다.  
* [넓은 엔터티 패턴](#wide-entities-pattern) - 여러 실제 엔터티를 사용하여 속성이 252개가 넘는 논리적 엔터티를 저장합니다.  
* [큰 엔터티 패턴](#large-entities-pattern) - Blob Storage를 사용하여 큰 속성 값을 저장합니다.  

### <a name="ensuring-consistency-in-your-stored-entities"></a>저장된 엔터티의 일관성 유지
데이터 수정을 최적화하기 위한 키 선택에 영향을 주는 다른 주요 요소는 원자성 트랜잭션을 사용하여 일관성을 유지하는 방법입니다. EGT는 동일한 파티션에 저장된 엔터티에서만 작동합니다.  

[테이블 디자인 패턴](#table-design-patterns) 섹션의 다음 패턴은 일관성 관리를 다룹니다.  

* [파티션 간 보조 인덱스 패턴](#intra-partition-secondary-index-pattern) - 서로 다른 **RowKey** 값을 사용하여 각 엔터티의 여러 복사본을 동일한 파티션에 저장하여 빠르고 효율적인 조회를 지원하며, 서로 다른 **RowKey** 값을 사용하여 대체 정렬 순서를 허용합니다.  
* [파티션 간 보조 인덱스 패턴](#inter-partition-secondary-index-pattern) - 서로 다른 RowKey 값을 사용하여 각 엔터티의 여러 복사본을 별도의 파티션과 별도의 테이블에 저장하여 빠르고 효율적인 조회를 지원하며, 서로 다른 **RowKey** 값을 사용하여 대체 정렬 순서를 허용합니다.  
* [결과적으로 일관성 있는 트랜잭션 패턴](#eventually-consistent-transactions-pattern) - Azure 큐를 사용하여 파티션 경계 또는 저장소 시스템 경계 간에 결과적으로 일관성 있는 동작을 지원합니다.
* [인덱스 엔터티 패턴](#index-entities-pattern) - 인덱스 엔터티를 유지 관리하여 엔터티 목록을 반환하는 효율적인 검색을 지원합니다.  
* [비정규화 패턴](#denormalization-pattern) - 관련 데이터를 단일 엔터티에 함께 통합하여 단일 지점 쿼리로 필요한 모든 데이터를 검색할 수 있습니다.  
* [데이터 계열 패턴](#data-series-pattern) - 전체 데이터 계열을 단일 엔터티에 저장하여 요청 수를 최소화합니다.  

엔터티 그룹 트랜잭션에 대한 자세한 내용은 [엔터티 그룹 트랜잭션](#entity-group-transactions)섹션을 참조하세요.  

### <a name="ensuring-your-design-for-efficient-modifications-facilitates-efficient-queries"></a>효율적인 수정을 위한 디자인이 효율적인 쿼리에도 유용
대부분의 경우 효율적인 쿼리를 위한 디자인은 효율적인 수정으로 이어지지만 항상 특정 시나리오에 이 사항이 적용되는지 평가해야 합니다. [테이블 디자인 패턴](#table-design-patterns) 섹션의 일부 패턴은 엔터티 쿼리와 수정 간의 장단점을 명시적으로 평가하므로 항상 각 작업 유형 수를 고려해야 합니다.  

[테이블 디자인 패턴](#table-design-patterns) 섹션의 다음 패턴은 효율적인 쿼리를 위한 디자인과 효율적인 데이터 수정을 위한 디자인 간의 장단점을 다룹니다.  

* [복합 키 패턴](#compound-key-pattern) - 복합 **RowKey** 키를 사용하여 클라이언트에서 단일 지점 쿼리로 관련 데이터를 조회하도록 할 수 있습니다.  
* [로그 테일 패턴](#log-tail-pattern) - 날짜 및 시간 역순으로 정렬된 *RowKey* 값을 사용하여 가장 최근에 파티션에 추가된 **n** 엔터티를 검색합니다.  

## <a name="encrypting-table-data"></a>테이블 데이터의 암호화
.NET Azure Storage 클라이언트 라이브러리는 작업 삽입 및 삭제의 문자열 엔터티 속성 암호화를 지원합니다. 암호화된 문자열은 서비스에 이진 속성으로 저장되고 암호 해독 후에는 다시 문자열로 변환됩니다.    

테이블의 경우, 암호화 정책 외에도 사용자가 암호화할 속성을 지정해야 합니다. 이것은 특성(TableEntity에서 파생 되는 POCO 엔터티)을 지정[EncryptProperty]하거나 암호화 해결 프로그램 요청 옵션에서 수행할 수 있습니다.  암호화 해결 프로그램은 파티션 키, 행 키, 그리고 속성 이름 및 암호화 여부 속성을 나타내는  Bool방식을 반환하는 대표자입니다. 암호화 하는 동안 클라이언트 라이브러리는 네트워크에 쓰는 동안 속성을 암호화 해야 하는지 여부를 결정하는데 이 정보를 사용합니다. 대리자 속성은 암호화 하는 방법 논리의 가능성도 제공 합니다. (예를 들어 X의 경우, A 속성을 암호화하고 그렇지 않은 경우 A와 B 속성을 암호화) 엔터티를 일거나 쿼리하는 동안 이 정보를 제공할 필요가 없습니다.

병합은 현재 지원 되지 않습니다. 속성의 하위 집합은 이전에 다른 키를 사용하여 암호화됐을 가능성이 있기 때문에 단순히 새로운 속성을 병합하는 것과 메타데이터를 업데이트 하는 것은 데이터 손실을 불러 올 수 있습니다. 서비스에서 기존 엔터티를 읽을 수 있는 추가 서비스 호출을 수행 하거나 속성 당 새 키를 사용하는 것 모두에 성능상의 이유로 적합하지 않습니다.     

테이블 데이터를 암호화에 대한 정보는 [클라이언트측 암호화 및 Microsoft Azure Storage에 대한 Azure Key Vault](../storage/common/storage-client-side-encryption.md)를 참조하십시오.  

## <a name="modeling-relationships"></a>관계 모델링
도메인 모델 빌드는 복잡한 시스템의 디자인에서 중요한 단계입니다. 일반적으로 엔터티와 해당 엔터티 간의 관계를 식별하는 모델링 프로세스를 사용하여 비즈니스 도메인을 이해하고 시스템 디자인에 대한 정보를 제공합니다. 이 섹션에서는 도메인 모델에서 일반적으로 발견되는 일부 관계 유형을 Table service의 디자인으로 변환하는 방법을 중점적으로 알아봅니다. 논리적 데이터 모델과 실제 NoSQL 기반 데이터 모델을 매핑하는 프로세스는 관계형 데이터베이스를 디자인할 때 사용되는 프로세스와 다릅니다. 관계형 데이터베이스 디자인에서는 일반적으로 중복을 최소화하는 데 최적화된 데이터 정규화 프로세스 및 데이터베이스 작동 방식의 구현을 추상화하는 선언적 쿼리 기능을 가정합니다.  

### <a name="one-to-many-relationships"></a>일대다 관계
비즈니스 도메인 개체 간의 일대다 관계는 빈번하게 발생합니다. 예를 들어 하나의 부서에 여러 직원이 있는 경우가 여기에 해당합니다. Table service에서 일대다 관계를 구현하는 방법에는 여러 가지가 있으며, 각 방법마다 특정 시나리오와 관련될 수 있는 장단점이 있습니다.  

수만 개의 부서 및 직원 엔터티가 있고, 모든 부서에 여러 직원이 있으며, 각 직원이 하나의 특정 부서에 연결된 대규모 다국적 기업을 예로 들어 보겠습니다. 별도의 부서 및 직원 엔터티를 저장하는 한 가지 접근 방식은 다음과 같습니다.  

![부서 및 직원 엔터티][1]

이 예는 **PartitionKey** 값을 기반으로 형식 간의 암시적 일대다의 관계를 보여 줍니다. 각 부서에는 여러 직원이 있을 수 있습니다.  

또한 이 예에서는 부서 엔터티와 해당 관련 직원 엔터티가 동일한 파티션에 있습니다. 여러 엔터티 유형에 대해 서로 다른 파티션, 테이블 또는 저장소 계정을 사용하도록 선택할 수 있습니다.  

다른 접근 방식은 다음 예와 같이 데이터를 비정규화하고 비정규화된 부서가 있는 직원 엔터티만 저장하는 것입니다. 이 특정 시나리오에서는 부서 관리자 정보를 변경할 수 있어야 하는 요구 사항이 있는 경우 이 비정규화된 접근 방식이 적합하지 않을 수 있습니다. 부서 관리자 정보를 변경하려면 부서의 모든 직원을 업데이트해야 하기 때문입니다.  

![직원 엔터티][2]

자세한 내용은 이 가이드의 뒷부분에 있는 [비정규화 패턴](#denormalization-pattern) 을 참조하세요.  

다음 표에는 일대다 관계가 있는 직원 및 부서 엔터티를 저장하는 측면에서 위에 설명된 각 접근 방식의 장단점이 요약되어 있습니다. 여러 작업을 수행할 빈도도 고려해야 합니다. 비용이 많이 드는 작업이 자주 발생하지 않는 경우에만 해당 작업을 디자인에 포함할 수도 있습니다.  

<table>
<tr>
<th>접근 방식</th>
<th>장점</th>
<th>단점</th>
</tr>
<tr>
<td>별도의 엔터티 유형, 동일한 파티션, 동일한 테이블</td>
<td>
<ul>
<li>단일 작업으로 부서 엔터티를 업데이트할 수 있습니다.</li>
<li>직원 엔터티를 업데이트/삽입/삭제할 때마다 부서 엔터티를 수정해야 하는 경우 EGT를 사용하여 일관성을 유지할 수 있습니다. 예를 들어 각 부서의 직원 수를 유지 관리하는 경우가 여기에 해당됩니다.</li>
</ul>
</td>
<td>
<ul>
<li>일부 클라이언트 활동의 경우 직원 및 부서 엔터티를 둘 다 검색해야 할 수 있습니다.</li>
<li>저장소 작업이 동일한 파티션에서 발생합니다. 대용량 트랜잭션의 경우 핫스폿이 발생할 수 있습니다.</li>
<li>EGT를 사용하여 직원을 새 부서로 이동할 수 없습니다.</li>
</ul>
</td>
</tr>
<tr>
<td>별도의 엔터티 형식, 서로 다른 파티션, 테이블 또는 저장소 계정</td>
<td>
<ul>
<li>단일 작업으로 부서 엔터티 또는 직원 엔터티를 업데이트할 수 있습니다.</li>
<li>대용량 트랜잭션의 경우 더 많은 파티션으로 부하를 분산할 수 있습니다.</li>
</ul>
</td>
<td>
<ul>
<li>일부 클라이언트 활동의 경우 직원 및 부서 엔터티를 둘 다 검색해야 할 수 있습니다.</li>
<li>직원을 업데이트/삽입/삭제하고 부서를 업데이트할 때 EGT를 사용하여 일관성을 유지할 수 없습니다. 예를 들어 부서 엔터티의 직원 수를 업데이트하는 경우가 여기에 해당합니다.</li>
<li>EGT를 사용하여 직원을 새 부서로 이동할 수 없습니다.</li>
</ul>
</td>
</tr>
<tr>
<td>단일 엔터티 유형으로 비정규화</td>
<td>
<ul>
<li>단일 요청으로 필요한 모든 정보를 검색할 수 있습니다.</li>
</ul>
</td>
<td>
<ul>
<li>부서 정보를 업데이트해야 하는 경우 일관성을 유지하는 데 많은 비용이 들 수 있습니다(부서의 모든 직원을 업데이트해야 함).</li>
</ul>
</td>
</tr>
</table>

이러한 옵션 간에 선택하는 방법 및 가장 중요한 장단점은 특정 애플리케이션 시나리오에 따라 다릅니다. 예를 들어 부서 엔터티를 수정하는 빈도, 모든 직원 쿼리를 수행하는 데 추가 부서 정보가 필요한지 여부, 파티션 또는 저장소 계정의 확장성 제한에 얼마나 근접했는지 여부 등에 따라 달라집니다.  

### <a name="one-to-one-relationships"></a>일대일 관계
도메인 모델은 엔터티 간의 일대일 관계를 포함할 수 있습니다. Table service에서 일대일 관계를 구현해야 하는 경우 두 관련 엔터티를 모두 검색해야 할 때 해당 엔터티를 연결하는 방법도 선택해야 합니다. 이 링크는 키 값의 명명 규칙에 따라 암시적일 수 있으며, 각 엔터티의 **PartitionKey** 및 **RowKey** 값 형식으로 링크를 해당 관련 엔터티에 저장할 경우 명시적일 수 있습니다. 관련 엔터티를 동일한 파티션에 저장해야 하는지 여부에 대한 자세한 내용은 [일대다 관계](#one-to-many-relationships)섹션을 참조하세요.  

Table service에서 일대일 관계를 구현하기 위한 구현 고려 사항도 있습니다.  

* 큰 엔터티 처리(자세한 내용은 [큰 엔터티 패턴](#large-entities-pattern)참조)  
* 액세스 제어 구현(자세한 내용은 [공유 액세스 서명을 사용하여 액세스 제어](#controlling-access-with-shared-access-signatures)참조)  

### <a name="join-in-the-client"></a>클라이언트에 조인
Table service에서 관계를 모델링하는 방법에는 여러 가지가 있지만 Table service를 사용하는 두 가지 주요 이유는 확장성과 성능이라는 점을 잊어서는 안 됩니다. 솔루션의 성능 및 확장성을 저하시키는 많은 관계를 모델링할 경우 모든 데이터 관계를 테이블 디자인에 빌드할 필요가 있는지 자문해 보아야 합니다. 클라이언트 애플리케이션에서 필요한 조인을 수행할 수 있도록 하면 디자인을 간소화하고 솔루션의 확장성 및 성능을 향상시킬 수 있습니다.  

예를 들어 자주 변경되지 않는 데이터가 포함된 작은 테이블이 있는 경우 이 데이터를 한 번 검색하여 클라이언트에 캐시할 수 있습니다. 그러면 동일한 데이터를 검색하기 위한 반복 작업을 방지할 수 있습니다. 이 가이드에서 살펴본 예제에서는 소규모 조직의 부서 집합이 작고 자주 변경되지 않을 수 있으므로 클라이언트 애플리케이션에서 한 번 다운로드하여 조회 데이터로 캐시할 수 있는 데이터로 적절합니다.  

### <a name="inheritance-relationships"></a>상속 관계
클라이언트 애플리케이션에서 상속 관계의 일부를 구성하는 클래스 집합을 사용하여 비즈니스 엔터티를 나타내는 경우 Table 서비스에서 이러한 엔터티를 쉽게 유지할 수 있습니다. 예를 들어 **사람** 이 추상 클래스인 클라이언트 애플리케이션에 다음과 같은 클래스 집합이 정의되어 있을 수 있습니다.

![상속 관계의 ER 다이어그램][3]

다음과 같이 엔터티를 사용하는 단일 Person 테이블을 사용하여 Table service에서 구체적 클래스 두 개의 인스턴스를 유지할 수 있습니다.  

![고객 엔터티 및 직원 엔터티 다이어그램][4]

클라이언트 코드에서 동일한 테이블에 있는 여러 엔터티 형식으로 작업하는 방법에 대한 자세한 내용은 이 가이드의 뒷부분에 있는 [형식이 다른 엔터티 형식 작업](#working-with-heterogeneous-entity-types) 섹션을 참조하세요. 이 섹션에서는 클라이언트 코드에서 엔터티 유형을 인식하는 방법에 대한 예제를 제공합니다.  

## <a name="table-design-patterns"></a>테이블 디자인 패턴
이전 섹션에서는 쿼리를 사용하여 엔터티 데이터를 검색하고 엔터티 데이터를 삽입, 업데이트 및 삭제하는 데 테이블 디자인을 최적화하는 방법에 대해 자세히 알아보았습니다. 이 섹션에서는 Table service 솔루션에서 사용하기에 적합한 몇 가지 패턴에 대해 알아봅니다. 또한 이 가이드의 앞부분에서 제기된 문제 및 장단점 중 일부를 실용적으로 해결할 수 있는 방법도 알아봅니다. 다음 다이어그램에는 서로 다른 패턴 간의 관계가 요약되어 있습니다.  

![테이블 디자인 패턴 이미지][5]

위 패턴 맵에는 이 가이드에 설명된 패턴(파란색)과 안티패턴(주황색) 간의 몇 가지 관계가 강조되어 있습니다. 물론 고려할 만한 다른 많은 패턴도 있습니다. 예를 들어 Table service의 주요 시나리오 중 하나는 [CQRS(Command Query Responsibility Segregation)](https://msdn.microsoft.com/library/azure/jj554200.aspx) 패턴에서 [구체화된 뷰 패턴](https://msdn.microsoft.com/library/azure/dn589782.aspx)을 사용하는 것입니다.  

### <a name="intra-partition-secondary-index-pattern"></a>파티션 간 보조 인덱스 패턴
서로 다른 **RowKey** 값(동일한 파티션에서)을 사용하여 각 엔터티의 여러 복사본을 저장하여 빠르고 효율적인 조회를 지원하며, 서로 다른 **RowKey** 값을 사용하여 대체 정렬 순서를 허용합니다. EGT를 사용하여 복사본 간의 업데이트를 일관성 있게 유지할 수 있습니다.  

#### <a name="context-and-problem"></a>컨텍스트 및 문제점
Table service는 **PartitionKey** 및 **RowKey** 값을 사용하여 엔터티를 자동으로 인덱싱합니다. 따라서 클라이언트 애플리케이션이 이러한 값을 사용하여 엔터티를 효율적으로 검색할 수 있습니다. 예를 들어 아래에 표시된 테이블 구조를 사용할 경우 클라이언트 애플리케이션은 지점 쿼리를 사용하여 부서 이름 및 직원 ID(**PartitionKey** 및 **RowKey** 값)로 개별 직원 엔터티를 검색할 수 있습니다. 또한 클라이언트는 각 부서 내에서 직원 ID별로 정렬된 엔터티를 검색할 수 있습니다.

![직원 엔터티][6]

전자 메일 주소와 같은 다른 속성 값으로 기반으로 직원 엔터티를 찾을 수 있도록 하려면 비효율적인 파티션 검색을 사용하여 일치하는 항목을 찾아야 합니다. 테이블 서비스에서는 보조 인덱스를 제공하지 않기 때문입니다. 또한 **RowKey** 와 다른 순서로 정렬된 직원 목록을 요청하는 옵션도 없습니다.  

#### <a name="solution"></a>해결 방법
보조 인덱스가 없는 문제를 해결하려면 각 엔터티의 여러 복사본을 다른 **RowKey** 값을 사용하는 각 복사본과 함께 저장하면 됩니다. 아래에 표시된 구조로 엔터티를 저장하면 전자 메일 주소 또는 직원 ID를 기반으로 직원 엔터티를 효율적으로 검색할 수 있습니다. **RowKey**의 접두사 값 "empid_" 및 "email_"은 전자 메일 주소 또는 직원 ID의 범위를 사용하여 단일 직원 또는 직원 범위를 쿼리할 수 있도록 해줍니다.  

![다양한 RowKey 값을 가진 직원 엔터티][7]

다음 두 필터 조건(직원 ID로 조회하는 필터와 전자 메일 주소로 조회하는 필터)은 모두 지점 쿼리를 지정합니다.  

* $filter=(PartitionKey eq 'Sales') and (RowKey eq 'empid_000223')  
* $filter=(PartitionKey eq 'Sales') and (RowKey eq 'email_jonesj@contoso.com')  

직원 엔터티 범위를 쿼리하는 경우 **RowKey**의 해당 접두사로 엔터티를 쿼리하여 직원 ID 순으로 정렬된 범위 또는 전자 메일 주소 순으로 정렬된 범위를 지정할 수 있습니다.  

* Sales 부서에서 직원 ID 범위가 000100~000199인 모든 직원을 찾으려면 다음을 사용합니다. $filter=(PartitionKey eq 'Sales') and (RowKey ge 'empid_000100') and (RowKey le 'empid_000199')  
* Sales 부서에서 이메일 주소가 'a'로 시작하는 모든 직원을 찾으려면 다음을 사용합니다. $filter=(PartitionKey eq 'Sales') and (RowKey ge 'email_a') and (RowKey lt 'email_b')  
  
  위 예제에 사용된 필터 구문은 Table service REST API에서 가져온 것입니다(자세한 내용은 [엔터티 쿼리](https://msdn.microsoft.com/library/azure/dd179421.aspx) 참조).  

#### <a name="issues-and-considerations"></a>문제 및 고려 사항
이 패턴을 구현할 방법을 결정할 때 다음 사항을 고려하세요.  

* Table Storage는 비교적 저렴하게 사용할 수 있으므로 중복 데이터 저장에 대한 비용 오버헤드가 주요 관심사여서는 안 됩니다. 그러나 항상 예상된 스토리지 요구 사항을 기반으로 디자인 비용을 평가하고, 클라이언트 애플리케이션에서 실행할 쿼리를 지원하는 데 필요한 경우에만 중복 엔터티를 추가해야 합니다.  
* 보조 인덱스 엔터티는 원래 엔터티와 동일한 파티션에 저장되므로 개별 파티션의 확장성 목표를 초과하지 않도록 해야 합니다.  
* EGT를 사용하여 엔터티의 두 복사본을 원자성으로 업데이트하는 방식으로 중복 엔터티를 서로 일관성 있게 유지할 수 있습니다. 이는 엔터티의 모든 복사본을 동일한 파티션에 저장해야 함을 의미합니다. 자세한 내용은 [엔터티 그룹 트랜잭션 사용](#entity-group-transactions)섹션을 참조하세요.  
* **RowKey** 에 사용된 값은 각 엔터티마다 고유해야 합니다. 복합 키 값을 사용하는 것이 좋습니다.  
* **RowKey** 의 숫자 값을 채우면(예: 직원 ID 000223) 상한 및 하한에 따라 올바르게 정렬 및 필터링됩니다.  
* 엔터티의 모든 속성을 복제할 필요는 없습니다. 예를 들어 **RowKey**에서 이메일 주소를 사용하여 엔터티를 조회하는 쿼리에 직원의 나이가 필요 없는 경우 이러한 엔터티의 구조는 다음과 같을 수 있습니다.

![직원 엔터티][8]

* 일반적으로 중복 데이터를 저장하고 단일 쿼리로 필요한 모든 데이터를 검색할 수 있도록 하는 것이 하나의 쿼리를 사용하여 엔터티를 찾고 다른 쿼리를 사용하여 필요한 데이터를 조회하는 것보다 좋습니다.  

#### <a name="when-to-use-this-pattern"></a>이 패턴을 사용해야 하는 경우
클라이언트 애플리케이션에서 다양한 키를 사용하여 엔터티를 검색해야 하는 경우, 클라이언트에서 다른 정렬 순서로 엔터티를 검색해야 하는 경우, 다양한 고유 값을 사용하여 각 엔터티를 식별할 수 있는 경우 등에 이 패턴을 사용합니다. 그러나 다른 **RowKey** 값을 사용하여 엔터티 조회를 수행할 때는 파티션 확장성 제한을 초과하지 않도록 해야 합니다.  

#### <a name="related-patterns-and-guidance"></a>관련 패턴 및 지침
이 패턴을 구현할 때 다음 패턴 및 지침도 관련이 있을 수 있습니다.  

* [파티션 내 보조 인덱스 패턴](#inter-partition-secondary-index-pattern)
* [복합 키 패턴](#compound-key-pattern)
* [엔터티 그룹 트랜잭션](#entity-group-transactions)
* [유형이 다른 엔터티 유형 작업](#working-with-heterogeneous-entity-types)

### <a name="inter-partition-secondary-index-pattern"></a>파티션 간 보조 인덱스 패턴
서로 다른 **RowKey** 값을 사용하여 각 엔터티의 여러 복사본을 별도의 파티션 또는 별도의 테이블에 저장하여 빠르고 효율적인 조회를 지원하며, 서로 다른 **RowKey** 값을 사용하여 대체 정렬 순서를 허용합니다.  

#### <a name="context-and-problem"></a>컨텍스트 및 문제점
Table service는 **PartitionKey** 및 **RowKey** 값을 사용하여 엔터티를 자동으로 인덱싱합니다. 따라서 클라이언트 애플리케이션이 이러한 값을 사용하여 엔터티를 효율적으로 검색할 수 있습니다. 예를 들어 아래에 표시된 테이블 구조를 사용할 경우 클라이언트 애플리케이션은 지점 쿼리를 사용하여 부서 이름 및 직원 ID(**PartitionKey** 및 **RowKey** 값)로 개별 직원 엔터티를 검색할 수 있습니다. 또한 클라이언트는 각 부서 내에서 직원 ID별로 정렬된 엔터티를 검색할 수 있습니다.  

![직원 엔터티][9]

전자 메일 주소와 같은 다른 속성 값으로 기반으로 직원 엔터티를 찾을 수 있도록 하려면 비효율적인 파티션 검색을 사용하여 일치하는 항목을 찾아야 합니다. 테이블 서비스에서는 보조 인덱스를 제공하지 않기 때문입니다. 또한 **RowKey** 와 다른 순서로 정렬된 직원 목록을 요청하는 옵션도 없습니다.  

이러한 엔티티에 대한 대량의 트랜잭션을 예상하고 있으며, 클라이언트를 제한하는 Table service 속도의 위험을 최소화하려고 합니다.  

#### <a name="solution"></a>해결 방법
보조 인덱스가 없는 문제를 해결하려면 각 엔터티의 여러 복사본을 다른 **PartitionKey** 및 **RowKey** 값을 사용하는 각 복사본과 함께 저장하면 됩니다. 아래에 표시된 구조로 엔터티를 저장하면 전자 메일 주소 또는 직원 ID를 기반으로 직원 엔터티를 효율적으로 검색할 수 있습니다. **PartitionKey**의 접두사 값 "empid_" 및 "email_"은 쿼리에 사용할 수 있는 인덱스를 구분할 수 있도록 해줍니다.  

![기본 인덱스가 있는 직원 엔티티 및 보조 인덱스가 있는 직원 엔터티][10]

다음 두 필터 조건(직원 ID로 조회하는 필터와 전자 메일 주소로 조회하는 필터)은 모두 지점 쿼리를 지정합니다.  

* $filter=(PartitionKey eq 'empid_Sales') and (RowKey eq '000223')
* $filter=(PartitionKey eq 'email_Sales') and (RowKey eq 'jonesj@contoso.com')  

직원 엔터티 범위를 쿼리하는 경우 **RowKey**의 해당 접두사로 엔터티를 쿼리하여 직원 ID 순으로 정렬된 범위 또는 전자 메일 주소 순으로 정렬된 범위를 지정할 수 있습니다.  

* Sales 부서에서 직원 ID 순으로 정렬하여 직원 ID 범위가 **000100**~**000199**인 모든 직원을 찾으려면 다음을 사용합니다. $filter=(PartitionKey eq 'empid_Sales') and (RowKey ge '000100') and (RowKey le '000199')  
* Sales 부서에서 직원 이메일 주소순으로 정렬하여 이메일 주소가 'a'로 시작하는 모든 직원을 찾으려면 다음을 사용합니다. $filter=(PartitionKey eq 'email_Sales') and (RowKey ge 'a') and (RowKey lt 'b')  

위 예제에 사용된 필터 구문은 Table service REST API에서 가져온 것입니다(자세한 내용은 [엔터티 쿼리](https://msdn.microsoft.com/library/azure/dd179421.aspx)참조).  

#### <a name="issues-and-considerations"></a>문제 및 고려 사항
이 패턴을 구현할 방법을 결정할 때 다음 사항을 고려하세요.  

* [결과적으로 일관성 있는 트랜잭션 패턴](#eventually-consistent-transactions-pattern) 을 사용하여 주 인덱스 엔터티 및 보조 인덱스 엔터티를 유지 관리함으로써 중복 엔터티를 서로 일관성 있게 유지할 수 있습니다.  
* Table Storage는 비교적 저렴하게 사용할 수 있으므로 중복 데이터 저장에 대한 비용 오버헤드가 주요 관심사여서는 안 됩니다. 그러나 항상 예상된 스토리지 요구 사항을 기반으로 디자인 비용을 평가하고, 클라이언트 애플리케이션에서 실행할 쿼리를 지원하는 데 필요한 경우에만 중복 엔터티를 추가해야 합니다.  
* **RowKey** 에 사용된 값은 각 엔터티마다 고유해야 합니다. 복합 키 값을 사용하는 것이 좋습니다.  
* **RowKey** 의 숫자 값을 채우면(예: 직원 ID 000223) 상한 및 하한에 따라 올바르게 정렬 및 필터링됩니다.  
* 엔터티의 모든 속성을 복제할 필요는 없습니다. 예를 들어 **RowKey**에서 전자 메일 주소를 사용하여 엔터티를 조회하는 쿼리에 직원의 나이가 필요 없는 경우 이러한 엔터티의 구조는 다음과 같을 수 있습니다.
  
  ![보조 인덱스가 있는 직원 엔터티][11]
* 일반적으로 중복 데이터를 저장하고 단일 쿼리로 필요한 모든 데이터를 검색할 수 있도록 하는 것이 하나의 쿼리를 사용하여 보조 인덱스에서 엔터티를 찾고 다른 쿼리를 사용하여 기본 인덱스에서 필요한 데이터를 조회하는 것보다 좋습니다.  

#### <a name="when-to-use-this-pattern"></a>이 패턴을 사용해야 하는 경우
클라이언트 애플리케이션에서 다양한 키를 사용하여 엔터티를 검색해야 하는 경우, 클라이언트에서 다른 정렬 순서로 엔터티를 검색해야 하는 경우, 다양한 고유 값을 사용하여 각 엔터티를 식별할 수 있는 경우 등에 이 패턴을 사용합니다. 다른 **RowKey** 값을 사용하여 엔터티 조회를 수행할 때는 파티션 확장성 제한을 초과하지 않도록 하려는 경우에 이 패턴을 사용합니다.  

#### <a name="related-patterns-and-guidance"></a>관련 패턴 및 지침
이 패턴을 구현할 때 다음 패턴 및 지침도 관련이 있을 수 있습니다.  

* [결과적으로 일관성 있는 트랜잭션 패턴](#eventually-consistent-transactions-pattern)  
* [파티션 간 보조 인덱스 패턴](#intra-partition-secondary-index-pattern)  
* [복합 키 패턴](#compound-key-pattern)  
* [엔터티 그룹 트랜잭션](#entity-group-transactions)  
* [유형이 다른 엔터티 유형 작업](#working-with-heterogeneous-entity-types)  

### <a name="eventually-consistent-transactions-pattern"></a>결과적으로 일관성 있는 트랜잭션 패턴
Azure 큐를 사용하여 파티션 경계 또는 저장소 시스템 경계 간에 결과적으로 일관성 있는 동작을 지원합니다.  

#### <a name="context-and-problem"></a>컨텍스트 및 문제점
EGT는 동일한 파티션 키를 공유하는 여러 엔터티 간의 원자성 트랜잭션을 지원합니다. 성능 및 확장성 때문에, 일관성 요구 사항이 있는 엔터티를 별도의 파티션 또는 별도의 저장소 시스템에 저장해야 할 수 있습니다. 이 시나리오에서는 EGT를 사용하여 일관성을 유지할 수 없습니다. 예를 들어 다음 엔터티 간에 결과적 일관성을 유지해야 하는 요구 사항이 있을 수 있습니다.  

* 동일한 테이블, 서로 다른 테이블 또는 서로 다른 저장소 계정의 두 파티션에 저장된 엔터티  
* Table service에 저장된 엔터티와 Blob service에 저장된 Blob  
* Table service에 저장된 엔터티와 파일 서비스에 저장된 파일  
* Azure Search 서비스를 사용하여 아직 인덱싱되지 않은 Table service에 저장된 엔터티  

#### <a name="solution"></a>해결 방법
Azure 큐를 사용하면 둘 이상의 파티션 또는 저장소 시스템 간에 결과적 일관성을 유지하는 솔루션을 구현할 수 있습니다.
이 접근 방식을 설명하기 위해 이전 직원 엔터티를 보관할 수 있어야 하는 요구 사항이 있는 것으로 가정합니다. 이전 직원 엔터티는 거의 쿼리되지 않으므로 현재 직원을 다루는 활동에서 제외해야 합니다. 이 요구 사항을 구현하기 위해 현재 직원을 **현재** 테이블에 저장하고 이전 직원을 **보관** 테이블에 저장합니다. 직원을 보관하려면 **현재** 테이블에서 해당 엔터티를 삭제하고 **보관** 테이블에 엔터티를 추가해야 하지만 EGT를 사용하여 이 두 작업을 수행할 수는 없습니다. 오류로 인해 하나의 엔터티가 두 테이블 모두에 표시되거나 아무 테이블에도 표시되지 않는 위험을 방지하려면 보관 작업이 결과적으로 일관성이 있어야 합니다. 다음 시퀀스 다이어그램에 이 작업의 단계가 요약되어 있습니다. 다음 텍스트에 예외 경로에 대한 자세한 정보가 나와 있습니다.  

![결과적 일관성을 위한 솔루션 다이어그램][12]

클라이언트가 메시지를 Azure 큐에 추가하여 보관 작업을 시작합니다(이 예제의 경우 employee #456 보관). 작업자 역할이 새 메시지에 대해 큐를 폴링합니다. 새 메시지를 찾은 경우 메시지를 읽고 숨겨진 복사본을 큐에 남겨 둡니다. 작업자 역할이 **현재** 테이블에서 엔터티의 복사본을 가져와 **보관** 테이블에 삽입한 다음 **현재** 테이블에서 원래 엔터티를 삭제합니다. 마지막으로 이전 단계에서 오류가 발생하지 않은 경우 작업자 역할이 큐에서 숨겨진 메시지를 삭제합니다.  

이 예제의 4단계에서는 직원을 **보관** 테이블에 삽입합니다. Blob service의 Blob 또는 파일 시스템의 파일에 직원을 추가할 수도 있습니다.  

#### <a name="recovering-from-failures"></a>오류 복구
작업자 역할이 보관 작업을 다시 시작해야 하는 것일 경우 **4**단계 및 **5**단계의 작업은 *멱등원*이어야 하는 것이 중요합니다. Table service를 사용하는 경우 **4**단계에서는 "삽입 또는 바꾸기" 작업을 사용하고, **5**단계에서는 사용 중인 클라이언트 라이브러리에서 "있는 경우 삭제" 작업을 사용해야 합니다. 다른 저장소 시스템을 사용하는 경우에는 적절한 idempotent 작업을 사용해야 합니다.  

작업자 역할이 **6**단계를 완료하지 못한 경우에는 시간 초과 후 작업자 역할이 작업을 다시 처리할 수 있도록 준비된 큐에 메시지가 다시 나타납니다. 작업자 역할은 큐의 메시지를 읽은 횟수를 확인할 수 있으며, 필요한 경우 별도의 큐로 보내 조사할 수 있도록 "포이즌" 메시지라는 플래그를 지정할 수 있습니다. 큐 메시지 읽기 및 큐에서 제거한 횟수 확인에 대한 자세한 내용은 [메시지 가져오기](https://msdn.microsoft.com/library/azure/dd179474.aspx)를 참조하세요.  

테이블 및 큐 서비스의 일부 오류는 일시적 오류이므로 클라이언트 애플리케이션에 이를 처리할 수 있는 적절한 재시도 논리가 있어야 합니다.  

#### <a name="issues-and-considerations"></a>문제 및 고려 사항
이 패턴을 구현할 방법을 결정할 때 다음 사항을 고려하세요.  

* 이 솔루션은 트랜잭션 격리를 제공하지 않습니다. 예를 들어 작업자 역할이 **4**단계와 **5**단계 사이에 있을 때 클라이언트가 **현재** 및 **보관** 테이블을 읽으면 일관성 없는 데이터 뷰가 표시될 수 있습니다. 결국 데이터는 일관성 있게 유지됩니다.  
* 결과적 일관성을 유지하려면 4단계와 5단계가 idempotent여야 합니다.  
* 여러 큐 및 작업자 역할 인스턴스를 사용하여 솔루션을 확장할 수 있습니다.  

#### <a name="when-to-use-this-pattern"></a>이 패턴을 사용해야 하는 경우
서로 다른 파티션 또는 테이블에 있는 엔터티 간의 결과적 일관성을 보장하려는 경우에 이 패턴을 사용합니다. 이 패턴을 확장하여 Table service와 Blob service 및 Azure가 아닌 다른 Storage 데이터 원본(예: 데이터베이스 또는 파일 시스템) 간의 작업에 대한 결과적 일관성을 유지할 수 있습니다.  

#### <a name="related-patterns-and-guidance"></a>관련 패턴 및 지침
이 패턴을 구현할 때 다음 패턴 및 지침도 관련이 있을 수 있습니다.  

* [엔터티 그룹 트랜잭션](#entity-group-transactions)  
* [병합 또는 바꾸기](#merge-or-replace)  

> [!NOTE]
> 트랜잭션 격리가 솔루션에 중요한 경우 EGT를 사용할 수 있도록 테이블을 다시 디자인해야 합니다.  
> 
> 

### <a name="index-entities-pattern"></a>인덱스 엔터티 패턴
인덱스 엔터티를 유지 관리하여 엔터티 목록을 반환하는 효율적인 검색을 지원합니다.  

#### <a name="context-and-problem"></a>컨텍스트 및 문제점
Table service는 **PartitionKey** 및 **RowKey** 값을 사용하여 엔터티를 자동으로 인덱싱합니다. 따라서 클라이언트 애플리케이션이 지점 쿼리를 사용하여 엔터티를 효율적으로 검색할 수 있습니다. 예를 들어 아래에 표시된 테이블 구조를 사용할 경우 클라이언트 애플리케이션은 부서 이름 및 직원 ID(**PartitionKey** 및 **RowKey**)를 사용하여 개별 직원 엔터티를 효율적으로 검색할 수 있습니다.  

![직원 엔터티][13]

이름과 같은 고유하지 않은 다른 속성 값을 기반으로 직원 엔터티 목록을 검색할 수 있도록 하려는 경우에는 인덱스를 사용하여 직접 조회하지 말고 비효율적인 파티션 검색을 사용하여 일치하는 항목을 찾아야 합니다. 테이블 서비스에서는 보조 인덱스를 제공하지 않기 때문입니다.  

#### <a name="solution"></a>해결 방법
위에 표시된 엔터티 구조에서 성으로 조회할 수 있도록 하려면 직원 ID 목록을 유지 관리해야 합니다. 특정 성(예: Jones)을 가진 직원 엔터티를 검색하려면 먼저 직원 ID 목록에서 성이 Jones인 직원을 찾은 다음 해당 직원 엔터티를 검색해야 합니다. 직원 ID 목록을 저장하는 기본 옵션에는 다음 세 가지가 있습니다.  

* Blob Storage 사용  
* 직원 엔터티와 동일한 파티션에 인덱스 엔터티 만들기  
* 별도의 파티션 또는 테이블에 인덱스 엔터티 만들기  

<u>옵션 #1: Blob Storage 사용</u>  

첫 번째 옵션의 경우 모든 고유한 성에 대한 Blob을 만들고, 각 Blob에 해당 성을 가진 직원의 **PartitionKey**(부서) 및 **RowKey**(직원 ID) 값 목록을 저장합니다. 직원을 추가하거나 삭제할 때는 관련 Blob의 내용이 직원 엔터티와 결과적으로 일관성이 있어야 합니다.  

<u>옵션 #2:</u> 동일한 파티션에 인덱스 엔터티 만들기  

두 번째 옵션의 경우 다음 데이터를 저장하는 인덱스 엔터티를 사용합니다.  

![성이 같은 직원 ID 목록을 포함하는 문자열이 있는 직원 엔터티][14]

**EmployeeIDs** 속성은 **RowKey**에 저장된 성을 가진 직원의 직원 ID 목록을 포함합니다.  

다음 단계에서는 두 번째 옵션을 사용하는 경우 새 직원을 추가할 때 따라야 하는 프로세스를 간략하게 설명합니다. 이 예제에서는 ID가 000152이고 성이 Jones인 직원을 Sales 부서에 추가합니다.  

1. **PartitionKey** 값 "Sales"와 **RowKey** 값 "Jones"를 사용하여 인덱스 엔터티를 검색합니다. 이 엔터티의 ETag를 2단계에서 사용하기 위해 저장합니다.  
2. 새 직원 ID를 EmployeeIDs 필드의 목록에 추가하여 새 직원 엔터티(**PartitionKey** 값 "Sales" 및 **RowKey** 값 "000152")를 삽입하고 인덱스 엔터티(**PartitionKey** 값 "Sales" 및 **RowKey** 값 "Jones")를 업데이트하는 엔터티 그룹 트랜젝션(즉 배치 작업)을 만듭니다. 엔터티 그룹 트랜잭션에 대한 자세한 내용은 [엔터티 그룹 트랜잭션](#entity-group-transactions)을 참조하세요.  
3. 낙관적 동시성 오류(다른 사람이 인덱스 엔터티를 수정한 경우)로 인해 엔터티 그룹 트랜잭션에 실패한 경우 1단계부터 다시 시작해야 합니다.  

두 번째 옵션을 사용하는 경우 이와 유사한 접근 방식을 사용하여 직원을 삭제할 수 있습니다. 직원의 성을 변경하는 것은 조금 더 복잡합니다. 세 엔터티, 즉 직원 엔터티, 이전 성의 인덱스 엔터티 및 새 성의 인덱스 엔터티를 업데이트하는 엔터티 그룹 트랜잭션를 실행해야 하기 때문입니다. 낙관적 동시성을 사용하여 업데이트를 수행하는 데 사용할 수 있는 ETag 값을 검색하려면 먼저 변경하기 전에 각 엔터티를 검색해야 합니다.  

다음 단계에서는 두 번째 옵션을 사용하는 경우 부서에서 지정된 성을 가진 모든 직원을 조회할 때 따라야 하는 프로세스를 간략하게 설명합니다. 이 예제에서는 Sales 부서에서 성이 Jones인 모든 직원을 조회합니다.  

1. **PartitionKey** 값 "Sales"와 **RowKey** 값 "Jones"를 사용하여 인덱스 엔터티를 검색합니다.  
2. EmployeeIDs 필드에서 직원 ID 목록을 구문 분석합니다.  
3. 이러한 각 직원에 대한 추가 정보(예: 전자 메일 주소)가 필요한 경우 2단계에서 가져온 직원 목록에서 **PartitionKey** 값 "Sales" 및 **RowKey** 값을 사용하여 각 직원 엔터티를 검색합니다.  

<u>옵션 #3:</u> 별도의 파티션 또는 테이블에 인덱스 엔터티 만들기  

세 번째 옵션의 경우 다음 데이터를 저장하는 인덱스 엔터티를 사용합니다.  

![성이 같은 직원 ID 목록을 포함하는 문자열이 있는 직원 엔터티][15]

**EmployeeIDs** 속성은 **RowKey**에 저장된 성을 가진 직원의 직원 ID 목록을 포함합니다.  

세 번째 옵션을 사용하는 경우에는 인덱스 엔터티가 직원 엔터티와 별도의 파티션에 있기 때문에 EGT를 사용하여 일관성을 유지할 수 없습니다. 인덱스 엔터티와 직원 엔터티가 결과적으로 일관성이 있도록 해야 합니다.  

#### <a name="issues-and-considerations"></a>문제 및 고려 사항
이 패턴을 구현할 방법을 결정할 때 다음 사항을 고려하세요.  

* 이 솔루션에서는 쿼리를 두 번 이상 실행하여 일치하는 엔터티를 검색해야 합니다. 즉, 인덱스 엔터티를 쿼리하여 **RowKey** 값 목록을 가져온 다음, 목록의 각 엔터티를 검색하는 쿼리를 실행합니다.  
* 개별 엔터티의 최대 크기가 1MB인 경우 이 솔루션의 옵션 2와 옵션 3에서는 지정된 성에 대한 직원 ID 목록이 1MB를 초과하지 않는 것으로 가정합니다. 직원 ID 목록이 1MB를 초과할 가능성이 있는 경우에는 옵션 1을 사용하여 인덱스 데이터를 Blob Storage에 저장합니다.  
* 옵션 2(EGT를 사용하여 직원 추가 및 삭제, 직원의 성 변경 처리)를 사용하는 경우 트랙잭션 볼륨이 지정된 파티션의 확장성 제한에 근접하는지 평가해야 합니다. 이 경우 큐를 사용하여 업데이트 요청을 처리하고, 인덱스 엔터티를 직원 엔터티와 별도의 파티션에 저장할 수 있도록 해주는 결과적으로 일관성 있는 솔루션(옵션 1 또는 옵션 3)을 고려해야 합니다.  
* 이 솔루션의 옵션 2에서는 부서 내에서 성으로 조회할 것으로 가정합니다. 예를 들어 Sales 부서에서 성이 Jones인 직원 목록을 검색할 수 있습니다. 전체 조직에서 성이 Jones인 모든 직원을 조회할 수 있도록 하려면 옵션 1 또는 옵션 3을 사용합니다.
* 결과적 일관성을 제공하는 큐 기반 솔루션을 구현할 수 있습니다. 자세한 내용은 [결과적으로 일관성 있는 트랜잭션 패턴](#eventually-consistent-transactions-pattern)을 참조하세요.  

#### <a name="when-to-use-this-pattern"></a>이 패턴을 사용해야 하는 경우
모두 공통된 속성 값(예: 성이 Jones인 모든 직원)을 공유하는 엔터티 집합을 조회하려는 경우에 이 패턴을 사용합니다.  

#### <a name="related-patterns-and-guidance"></a>관련 패턴 및 지침
이 패턴을 구현할 때 다음 패턴 및 지침도 관련이 있을 수 있습니다.  

* [복합 키 패턴](#compound-key-pattern)  
* [결과적으로 일관성 있는 트랜잭션 패턴](#eventually-consistent-transactions-pattern)  
* [엔터티 그룹 트랜잭션](#entity-group-transactions)  
* [유형이 다른 엔터티 유형 작업](#working-with-heterogeneous-entity-types)  

### <a name="denormalization-pattern"></a>비정규화 패턴
관련 데이터를 단일 엔터티에 함께 통합하여 단일 지점 쿼리로 필요한 모든 데이터를 검색할 수 있습니다.  

#### <a name="context-and-problem"></a>컨텍스트 및 문제점
관계형 데이터베이스에서는 일반적으로 데이터를 정규화하여 중복을 제거함으로써 여러 테이블에서 데이터를 검색하는 쿼리를 실행합니다. Azure 테이블의 데이터를 정규화한 경우 클라이언트와 버 간에 여러 번 왕복하여 관련 데이터를 검색해야 합니다. 예를 들어 아래 표시된 테이블 구조에서 부서에 대한 세부 정보를 검색하려면 두 번 왕복해야 합니다. 즉, 관리자 ID가 포함된 부서 엔터티를 가져온 다음 다른 요청을 통해 직원 엔터티에서 관리자의 세부 정보를 가져와야 합니다.  

![부서 엔터티 및 직원 엔터티][16]

#### <a name="solution"></a>해결 방법
두 개의 별도 엔터티에 데이터를 저장하는 대신 데이터를 비정규화하여 부서 엔터티에 관리자 세부 정보의 복사본을 유지합니다. 예를 들면 다음과 같습니다.  

![비정규화되고 결합된 부서 엔터티][17]

이러한 속성이 저장된 부서 엔터티의 경우 이제 지점 쿼리를 사용하여 부서에 대한 모든 세부 정보를 검색할 수 있습니다.  

#### <a name="issues-and-considerations"></a>문제 및 고려 사항
이 패턴을 구현할 방법을 결정할 때 다음 사항을 고려하세요.  

* 일부 데이터를 두 번 저장하는 것과 관련된 약간의 비용 오버헤드가 있습니다. 그러나 일반적으로 성능 이점(저장소 서비스에 대한 요청 수 감소로 인한 이점)이 저장소 비용(이 비용은 부서 세부 정보를 가져오는 데 필요한 트랜잭션 수의 감소로 인해 부분적으로 상쇄됨)을 훨씬 능가합니다.  
* 관리자에 대한 정보를 저장하는 두 엔터티의 일관성을 유지해야 합니다. EGT를 사용하여 여러 엔터티를 단일 원자성 트랜잭션에서 업데이트하는 방식으로 일관성 문제를 처리할 수 있습니다. 이 경우 부서 엔터티와 부서 관리자에 대한 직원 엔터티는 동일한 파티션에 저장됩니다.  

#### <a name="when-to-use-this-pattern"></a>이 패턴을 사용해야 하는 경우
관련 정보를 자주 조회해야 하는 경우에 이 패턴을 사용합니다. 이 패턴은 클라이언트에서 필요한 데이터를 검색하기 위해 실행해야 하는 쿼리 수를 줄여 줍니다.  

#### <a name="related-patterns-and-guidance"></a>관련 패턴 및 지침
이 패턴을 구현할 때 다음 패턴 및 지침도 관련이 있을 수 있습니다.  

* [복합 키 패턴](#compound-key-pattern)  
* [엔터티 그룹 트랜잭션](#entity-group-transactions)  
* [유형이 다른 엔터티 유형 작업](#working-with-heterogeneous-entity-types)

### <a name="compound-key-pattern"></a>복합 키 패턴
복합 **RowKey** 값을 사용하여 클라이언트에서 단일 지점 쿼리로 관련 데이터를 조회하도록 할 수 있습니다.  

#### <a name="context-and-problem"></a>컨텍스트 및 문제점
관계형 데이터베이스에서는 쿼리에서 조인을 사용하여 관련 데이터 조각을 단일 쿼리의 클라이언트로 반환하는 것이 자연스러운 일입니다. 예를 들어 직원 ID를 사용하여 해당 직원에 대한 성과 및 검토 데이터가 포함된 관련 엔터티 목록을 조회할 수 있습니다.  

다음 구조를 사용하여 직원 엔터티를 Table service에 저장하는 경우를 가정해 보겠습니다.  

![직원 엔터티][18]

또한 매년 직원이 조직을 위해 일한 성과 및 검토와 관련된 기록 데이터를 저장하고 연도별로 이 정보에 액세스할 수 있어야 합니다. 한 가지 옵션은 다음 구조로 엔터티를 저장하는 다른 테이블을 만드는 것입니다.  

![직원 검토 엔터티][19]

이 접근 방식을 사용하면 일부 정보(예: 이름 및 성)를 새 엔터티에 복제하여 단일 요청으로 데이터를 검색할 수 있습니다. 그러나 EGT를 사용하여 두 엔터티를 원자성으로 업데이트할 수 없기 때문에 강력한 일관성을 유지할 수 없습니다.  

#### <a name="solution"></a>해결 방법
다음 구조의 엔터티를 사용하여 새 엔터티 유형을 원래 테이블에 저장합니다.  

![복합 키가 있는 직원 엔터티][20]

이제 **RowKey** 는 직원 ID와 검토 데이터의 연도로 구성된 복합 키이며 이 키를 사용하여 단일 엔터티에 대한 단일 요청으로 직원의 성과 및 검토 데이터를 검색할 수 있습니다.  

다음 예제에서는 특정 직원(예: Sales 부서의 직원 000123)에 대한 모든 검토 데이터를 검색할 수 있는 방법을 간략하게 설명합니다.  

$filter=(PartitionKey eq 'Sales') and (RowKey ge 'empid_000123') and (RowKey lt 'empid_000124')&$select=RowKey,Manager Rating,Peer Rating,Comments  

#### <a name="issues-and-considerations"></a>문제 및 고려 사항
이 패턴을 구현할 방법을 결정할 때 다음 사항을 고려하세요.  

* **RowKey** 값을 쉽게 구문 분석할 수 있는 적절한 구분 기호 문자(예: **000123_2012**)를 사용해야 합니다.  
* 또한 이 엔터티를 동일한 직원에 대한 관련 데이터가 포함된 다른 엔터티와 동일한 파티션에 저장합니다. 이렇게 하면 EGT를 사용하여 강력한 일관성을 유지할 수 있습니다.
* 이 패턴이 적절한지 확인하기 위해 데이터를 쿼리할 빈도를 고려해야 합니다.  예를 들어 검토 데이터에는 자주 액세스하지 않고 기본 직원 데이터에는 자주 액세스하는 경우 이를 별도의 엔터티로 유지해야 합니다.  

#### <a name="when-to-use-this-pattern"></a>이 패턴을 사용해야 하는 경우
자주 쿼리하는 하나 이상의 관련 엔터티를 저장해야 하는 경우에 이 패턴을 사용합니다.  

#### <a name="related-patterns-and-guidance"></a>관련 패턴 및 지침
이 패턴을 구현할 때 다음 패턴 및 지침도 관련이 있을 수 있습니다.  

* [엔터티 그룹 트랜잭션](#entity-group-transactions)  
* [유형이 다른 엔터티 유형 작업](#working-with-heterogeneous-entity-types)  
* [결과적으로 일관성 있는 트랜잭션 패턴](#eventually-consistent-transactions-pattern)  

### <a name="log-tail-pattern"></a>로그 테일 패턴
날짜 및 시간 역순으로 정렬된 *RowKey* 값을 사용하여 가장 최근에 파티션에 추가된 **n** 개의 엔터티를 검색합니다.  

> [!NOTE]
> Azure DB에서 Azure Table API에서 반환한 쿼리 결과 파티션 키 또는 행 키로 정렬 되지 않습니다. 따라서 이 패턴은 Azure Cosmos DB가 아닌 Azure Table Storage에 적합합니다. 자세한 기능 차이 목록에 대해서는 [Azure Table Storage와 Azure Cosmos DB의 Table API 간 차이점](faq.md#where-is-table-api-not-identical-with-azure-table-storage-behavior)을 참조하세요.

#### <a name="context-and-problem"></a>컨텍스트 및 문제점
일반적인 요구 사항은 가장 최근에 생성된 엔터티(예: 직원이 제출한 가장 최근 비용 청구 10개)를 검색할 수 있는 것입니다. 테이블 쿼리는 집합에서 첫 번째 엔터티를 반환하는 **$top** 쿼리 작업을 지원합니다. 집합에 있는 마지막 *n*개의 엔터티를 반환하는 동등한 쿼리 작업은 없습니다.  

#### <a name="solution"></a>해결 방법
가장 최근 항목이 항상 테이블의 첫 번째 항목이 되도록 날짜/시간 역순으로 자연스럽게 정렬하는 **RowKey** 를 사용하여 엔터티를 정렬합니다.  

예를 들어 직원이 제출한 가장 최근 비용 청구 10개를 검색하려면 현재 날짜/시간에서 파생된 역방향 틱 값을 사용하면 됩니다. 다음 C# 코드 샘플은 가장 최근 항목부터 가장 오래된 항목까지 정렬하는 **RowKey** 에 대한 적절한 "반전된 틱" 값을 만드는 한 가지 방법을 보여 줍니다.  

`string invertedTicks = string.Format("{0:D19}", DateTime.MaxValue.Ticks - DateTime.UtcNow.Ticks);`  

다음 코드를 사용하여 날짜/시간 값을 되돌릴 수 있습니다.  

`DateTime dt = new DateTime(DateTime.MaxValue.Ticks - Int64.Parse(invertedTicks));`  

테이블 쿼리는 다음과 같습니다.  

`https://myaccount.table.core.windows.net/EmployeeExpense(PartitionKey='empid')?$top=10`  

#### <a name="issues-and-considerations"></a>문제 및 고려 사항
이 패턴을 구현할 방법을 결정할 때 다음 사항을 고려하세요.  

* 문자열 값이 예상대로 정렬되도록 하려면 선행 0으로 역방향 틱 값을 채워야 합니다.  
* 파티션 수준의 확장성 목표를 알아야 합니다. 핫스폿 파티션을 만들지 않도록 주의하세요.  

#### <a name="when-to-use-this-pattern"></a>이 패턴을 사용해야 하는 경우
날짜/시간 역순으로 엔터티에 액세스해야 하는 경우 또는 가장 최근에 추가된 엔터티에 액세스해야 하는 경우에 이 패턴을 사용합니다.  

#### <a name="related-patterns-and-guidance"></a>관련 패턴 및 지침
이 패턴을 구현할 때 다음 패턴 및 지침도 관련이 있을 수 있습니다.  

* [앞/뒤에 추가된 안티패턴](#prepend-append-anti-pattern)  
* [엔터티 검색](#retrieving-entities)  

### <a name="high-volume-delete-pattern"></a>대용량 삭제 패턴
동시 삭제할 모든 엔터티를 고유한 별도의 테이블에 저장하여 대용량 엔터티 삭제를 지원합니다. 테이블을 삭제하면 엔터티가 삭제됩니다.  

#### <a name="context-and-problem"></a>컨텍스트 및 문제점
대부분의 애플리케이션은 클라이언트 애플리케이션에서 더 이상 사용할 필요가 없거나 애플리케이션이 다른 저장 매체에 보관한 경우 이전 데이터를 삭제합니다. 일반적으로 이러한 데이터는 날짜로 식별합니다. 예를 들어, 60일이 지난 모든 로그인 요청에 대한 레코드를 삭제해야 할 수 있습니다.  

한 가지 가능한 디자인은 **RowKey**에서 로그인 요청 날짜 및 시간을 사용하는 것입니다.  

![로그인 시도 엔터티][21]

이 접근 방식을 사용하면 애플리케이션이 각 사용자에 대한 로그인 엔터티를 별도의 파티션에 삽입하고 삭제할 수 있기 때문에 파티션 핫스폿이 방지됩니다. 그러나 이 접근 방식은 엔터티 수가 많은 경우 삭제할 모든 엔터티를 식별하기 위해 먼저 테이블 검색을 수행한 다음 각 이전 엔터티를 삭제해야 하기 때문에 시간과 비용이 많이 들 수 있습니다. 여러 삭제 요청을 EGT로 일괄 처리하면 이전 엔터티를 삭제하는 데 필요한 서버 왕복 횟수를 줄일 수 있습니다.  

#### <a name="solution"></a>해결 방법
각 로그인 시도 날짜에 별도의 테이블을 사용합니다. 위의 엔터티 디자인을 사용하면 엔터티를 삽입할 때 핫스폿을 방지할 수 있으며, 매일 수많은 개별 로그인 엔터티를 찾아서 삭제하는 대신 매일 하나의 테이블만 삭제(단일 저장소 작업)하면 되므로 이전 엔터티 삭제가 간편해집니다.  

#### <a name="issues-and-considerations"></a>문제 및 고려 사항
이 패턴을 구현할 방법을 결정할 때 다음 사항을 고려하세요.  

* 디자인이 애플리케이션에서 데이터를 사용하는 다른 방식(예: 특정 엔터티 조회, 다른 데이터와 연결 또는 집계 정보 생성)을 지원하나요?  
* 디자인이 새 엔터티를 삽입할 때 핫스폿을 방지하나요?  
* 테이블을 삭제한 후 동일한 테이블 이름을 다시 사용하려는 경우 지연이 발생할 수 있습니다. 항상 고유한 테이블 이름을 사용하는 것이 좋습니다.  
* 새 테이블을 처음 사용할 때 Table service에서 액세스 패턴을 학습하고 노드 간에 파티션을 분산하는 동안 일부 속도 제한이 발생할 수 있습니다. 새 테이블을 만들어야 하는 빈도를 고려해야 합니다.  

#### <a name="when-to-use-this-pattern"></a>이 패턴을 사용해야 하는 경우
동시에 삭제해야 하는 엔터티가 많은 경우에 이 패턴을 사용합니다.  

#### <a name="related-patterns-and-guidance"></a>관련 패턴 및 지침
이 패턴을 구현할 때 다음 패턴 및 지침도 관련이 있을 수 있습니다.  

* [엔터티 그룹 트랜잭션](#entity-group-transactions)
* [엔터티 수정](#modifying-entities)  

### <a name="data-series-pattern"></a>데이터 계열 패턴
전체 데이터 계열을 단일 엔터티에 저장하여 요청 수를 최소화합니다.  

#### <a name="context-and-problem"></a>컨텍스트 및 문제점
일반적인 시나리오에서 애플리케이션은 보통 모든 엔터티를 동시에 검색하는 데 필요한 데이터 계열을 저장합니다. 예를 들어 애플리케이션은 각 직원이 매시간 보내는 IM 메시지 수를 기록한 다음, 이 정보를 사용하여 각 사용자가 이전 24시간 동안 보낸 메시지 수를 표시할 수 있습니다. 한 가지 디자인은 각 직원에 대한 24개의 엔터티를 저장하는 것입니다.  

![메시지 통계 엔터티][22]

이 디자인을 사용하면 애플리케이션이 메시지 수 값을 업데이트해야 할 때마다 각 직원에 대한 엔터티를 쉽게 찾아서 업데이트할 수 있습니다. 그러나 이전 24시간 동안의 활동에 대한 차트를 그리기 위해 정보를 검색하려면 24개의 엔터티를 검색해야 합니다.  

#### <a name="solution"></a>해결 방법
개별 속성과 함께 다음 디자인을 사용하여 각 시간에 대한 메시지 수를 저장합니다.  

![별도의 속성이 있는 메시지 통계 엔터티][23]

이 디자인을 사용하면 병합 작업을 통해 특정 시간 동안 각 직원의 메시지 수를 업데이트할 수 있습니다. 이제 단일 엔터티에 대한 요청을 사용하여 차트를 그리는 데 필요한 모든 정보를 검색할 수 있습니다.  

#### <a name="issues-and-considerations"></a>문제 및 고려 사항
이 패턴을 구현할 방법을 결정할 때 다음 사항을 고려하세요.  

* 전체 데이터 계열을 단일 엔터티에 포함할 수 없는 경우(하나의 엔터티가 최대 252개의 속성을 유지할 수 있음) Blob와 같은 다른 데이터 저장소를 사용합니다.  
* 여러 클라이언트에서 동시에 엔터티를 업데이트하는 경우 **ETag** 를 사용하여 낙관적 동시성을 구현해야 합니다. 여러 클라이언트가 있는 경우 높은 경합이 발생할 수 있습니다.  

#### <a name="when-to-use-this-pattern"></a>이 패턴을 사용해야 하는 경우
개별 엔터티와 연관된 데이터 계열을 업데이트하고 검색해야 하는 경우에 이 패턴을 사용합니다.  

#### <a name="related-patterns-and-guidance"></a>관련 패턴 및 지침
이 패턴을 구현할 때 다음 패턴 및 지침도 관련이 있을 수 있습니다.  

* [큰 엔터티 패턴](#large-entities-pattern)  
* [병합 또는 바꾸기](#merge-or-replace)  
* [결과적으로 일관성 있는 트랜잭션 패턴](#eventually-consistent-transactions-pattern) (데이터 계열을 Blob에 저장하는 경우)  

### <a name="wide-entities-pattern"></a>넓은 엔터티 패턴
여러 실제 엔터티를 사용하여 속성이 252개가 넘는 논리적 엔터티를 저장합니다.  

#### <a name="context-and-problem"></a>컨텍스트 및 문제점
개별 엔터티는 252개가 넘는 속성(필수 시스템 속성 제외)을 가질 수 없으며, 총 1MB가 넘는 데이터를 저장할 수 없습니다. 관계형 데이터베이스는 일반적으로 새 테이블을 추가하고 일대일 관계를 적용하여 행 크기에 대한 제한을 피합니다.  

#### <a name="solution"></a>해결 방법
Table service를 사용하면 여러 엔터티를 저장하여 252개가 넘는 속성을 가진 대규모 단일 비즈니스 개체를 나타낼 수 있습니다. 예를 들어 각 직원이 지난 365일 동안 보낸 IM 메시지 수를 저장하려는 경우 스키마가 서로 다른 두 개의 엔터티를 사용하는 다음 디자인을 사용할 수 있습니다.  

![Rowkey 01이 있는 메시지 통계 엔터티 및 Rowkey 02가 있는 메시지 통계 엔터티][24]

서로 동기화된 상태로 유지하기 위해 두 엔터티를 모두 업데이트해야 하는 변경 내용을 적용하려는 경우 EGT를 사용할 수 있습니다. 그렇지 않으면 단일 병합 작업을 사용하여 특정 날짜의 메시지 수를 업데이트할 수 있습니다. 개별 직원에 대한 모든 데이터를 검색하려면 **PartitionKey** 및 **RowKey** 값을 둘 다 사용하는 두 가지 효율적인 요청으로 이 작업을 수행할 수 있는 엔터티를 모두 검색해야 합니다.  

#### <a name="issues-and-considerations"></a>문제 및 고려 사항
이 패턴을 구현할 방법을 결정할 때 다음 사항을 고려하세요.  

* 전체 논리적 엔터티를 검색하는 데에는 적어도 두 개의 저장소 트랜잭션이 필요합니다. 그 중 하나는 각 실제 엔터티를 검색합니다.  

#### <a name="when-to-use-this-pattern"></a>이 패턴을 사용해야 하는 경우
속성의 크기 또는 개수가 Table service의 개별 엔터티에 대한 한도를 초과하는 엔터티를 저장해야 하는 경우에 이 패턴을 사용합니다.  

#### <a name="related-patterns-and-guidance"></a>관련 패턴 및 지침
이 패턴을 구현할 때 다음 패턴 및 지침도 관련이 있을 수 있습니다.  

* [엔터티 그룹 트랜잭션](#entity-group-transactions)
* [병합 또는 바꾸기](#merge-or-replace)

### <a name="large-entities-pattern"></a>큰 엔터티 패턴
Blob Storage를 사용하여 큰 속성 값을 저장합니다.  

#### <a name="context-and-problem"></a>컨텍스트 및 문제점
개별 엔터티는 총 1MB가 넘는 데이터를 저장할 수 없습니다. 하나 이상의 속성에 엔터티의 총 크기가 이 값을 초과하게 만드는 값이 저장된 경우에는 Table service에 전체 엔터티를 저장할 수 없습니다.  

#### <a name="solution"></a>해결 방법
하나 이상의 속성에 많은 데이터가 포함되어 있어 엔터티의 크기가 1MB를 초과하는 경우 Blob service에 데이터를 저장한 다음 엔터티의 속성에 해당 Blob의 주소를 저장할 수 있습니다. 예를 들어 직원의 사진을 Blob Storage에 저장하고 해당 사진의 링크를 직원 엔터티의 **사진** 속성에 저장할 수 있습니다.  

![사진의 문자열이 Blob Storage를 가리키는 직원 엔터티][25]

#### <a name="issues-and-considerations"></a>문제 및 고려 사항
이 패턴을 구현할 방법을 결정할 때 다음 사항을 고려하세요.  

* Table service의 엔터티와 Blob service의 데이터 간에 결과적 일관성을 유지하려면 [결과적으로 일관성 있는 트랜잭션 패턴](#eventually-consistent-transactions-pattern) 을 사용하여 엔터티를 유지합니다.
* 전체 엔터티를 검색하는 데에는 적어도 두 개의 저장소 트랜잭션이 필요합니다. 그 중 하나는 엔터티를 검색하고, 또 하나는 Blob 데이터를 검색합니다.  

#### <a name="when-to-use-this-pattern"></a>이 패턴을 사용해야 하는 경우
크기가 Table service의 개별 엔터티에 대한 제한을 초과하는 엔터티를 저장해야 하는 경우에 이 패턴을 사용합니다.  

#### <a name="related-patterns-and-guidance"></a>관련 패턴 및 지침
이 패턴을 구현할 때 다음 패턴 및 지침도 관련이 있을 수 있습니다.  

* [결과적으로 일관성 있는 트랜잭션 패턴](#eventually-consistent-transactions-pattern)  
* [넓은 엔터티 패턴](#wide-entities-pattern)

<a name="prepend-append-anti-pattern"></a>

### <a name="prependappend-anti-pattern"></a>앞에 추가/뒤에 추가 안티패턴
대용량 삽입이 있는 경우 여러 파티션 간에 삽입을 분산하여 확장성을 높입니다.  

#### <a name="context-and-problem"></a>컨텍스트 및 문제점
저장된 엔터티 앞 또는 뒤에 엔터티를 추가하면 일반적으로 애플리케이션에서 파티션 시퀀스의 첫 번째 또는 마지막 파티션에 새 엔터티를 추가합니다. 이 경우 지정된 시간의 모든 삽입이 동일한 파티션에서 발생하므로 테이블 서비스에서 여러 노드 간에 삽입 부하를 분산할 수 없는 핫스폿이 생성되며, 애플리케이션이 파티션의 확장성 목표에 도달하게 될 수 있습니다. 예를 들어 직원의 네트워크 및 리소스 액세스를 기록하는 애플리케이션이 있는 경우 아래 표시된 엔터티 구조에서는 트랜잭션 볼륨이 개별 파티션의 확장성 목표에 도달하면 현재 시간의 파티션이 핫스폿이 될 수 있습니다.  

![직원 엔터티][26]

#### <a name="solution"></a>해결 방법
다음 대체 엔터티 구조는 애플리케이션에서 이벤트를 기록할 때 특정 파티션의 핫스폿을 방지합니다.  

![연도, 월, 일, 시간 및 이벤트 ID로 구성된 RowKey가 있는 직원 엔터티][27]

이 예제에서는 **PartitionKey**와 **RowKey**가 복합 키입니다. **PartitionKey** 는 부서 및 직원 ID를 모두 사용하여 여러 파티션 간에 로깅을 분산합니다.  

#### <a name="issues-and-considerations"></a>문제 및 고려 사항
이 패턴을 구현할 방법을 결정할 때 다음 사항을 고려하세요.  

* 삽입 시 핫 파티션 생성을 효율적으로 방지하는 대체 키 구조가 클라이언트 애플리케이션의 쿼리를 지원하나요?  
* 예상한 트랜잭션 볼륨이 개별 파티션에 대한 확장성 목표에 도달하고 저장소 서비스에 의해 제한될 가능성이 있음을 의미하나요?  

#### <a name="when-to-use-this-pattern"></a>이 패턴을 사용해야 하는 경우
핫 파티션에 액세스할 때 트랜잭션 볼륨으로 인해 저장소 서비스에 의한 속도 제한이 발생할 수 있을 때는 앞에 추가/뒤에 추가 안티패턴을 사용하지 마세요.  

#### <a name="related-patterns-and-guidance"></a>관련 패턴 및 지침
이 패턴을 구현할 때 다음 패턴 및 지침도 관련이 있을 수 있습니다.  

* [복합 키 패턴](#compound-key-pattern)  
* [로그 테일 패턴](#log-tail-pattern)  
* [엔터티 수정](#modifying-entities)  

### <a name="log-data-anti-pattern"></a>로그 데이터 안티패턴
일반적으로 Table service 대신 Blob service를 사용하여 로그 데이터를 저장해야 합니다.  

#### <a name="context-and-problem"></a>컨텍스트 및 문제점
로그 데이터의 일반적인 사용 사례는 특정 날짜/시간 범위의 선택적 로그 항목을 검색하는 것입니다. 예를 들어 애플리케이션이 특정 날짜의 15:04에서 15:06 사이에 기록한 모든 오류 및 중요 메시지를 찾을 수 있습니다. 로그 엔터티를 저장한 파티션을 확인하는 데에는 로그 메시지의 날짜 및 시간을 사용하지 않습니다. 메시지의 날짜 및 시간을 사용하면 지정된 시간에 모든 로그 엔터티가 동일한 **PartitionKey** 값을 공유하기 때문에 핫 파티션이 발생합니다([앞에 추가/뒤에 추가 안티패턴](#prepend-append-anti-pattern) 섹션 참조). 예를 들어 로그 메시지에 대한 다음 엔터티 스키마의 경우 애플리케이션이 현재 날짜 및 시간에 대한 모든 로그 메시지를 파티션에 쓰기 때문에 핫 파티션이 발생합니다.  

![로그 메시지 엔터티][28]

이 예제에서 **RowKey** 는 로그 메시지가 날짜/시간 순으로 정렬되어 저장되도록 해당 로그 메시지의 날짜 및 시간을 포함하며, 여러 로그 메시지에서 동일한 날짜 및 시간을 공유하는 경우의 메시지 ID를 포함합니다.  

또 다른 접근 방식은 애플리케이션이 파티션 범위에 메시지를 쓰도록 하는 **PartitionKey** 를 사용하는 것입니다. 예를 들어 로그 메시지의 원본이 여러 파티션 간에 메시지를 분산할 수 있는 방법을 제공하는 경우 다음 엔터티 스키마를 사용할 수 있습니다.  

![로그 메시지 엔터티][29]

그러나 이 스키마의 문제점은 특정 시간대의 모든 로그 메시지를 검색하려면 테이블의 모든 파티션을 검색해야 한다는 점입니다.

#### <a name="solution"></a>해결 방법
이전 섹션에서는 Table service를 사용하여 로그 항목을 저장하려는 경우의 문제점을 설명하고 불만족스러운 두 가지 디자인을 제시했습니다. 한 가지 솔루션은 로그 메시지 작성 성능의 저하 위험으로 인해 핫 파티션이 발생했으며, 다른 솔루션은 특정 시간대의 로그 메시지를 검색하려면 테이블의 모든 파티션을 검색해야 하기 때문에 쿼리 성능이 저하되었습니다. Blob 스토리지는 이 유형의 시나리오에 보다 효율적인 솔루션을 제공하며, Azure Storage Analytics에서는 수집한 로그 데이터를 이 방법으로 저장합니다.  

이 섹션에서는 일반적으로 범위로 쿼리한 데이터를 저장하는 접근 방식을 보여 주면서 Storage Analytics가 로그 데이터를 Blob 스토리지에 저장하는 방법을 간략하게 설명합니다.  

Storage Analytics는 로그 메시지를 구분 기호로 분리된 형식으로 여러 Blob에 저장합니다. 구분 기호로 분리된 형식을 사용하면 클라이언트 애플리케이션에서 로그 메시지의 데이터를 쉽게 구문 분석할 수 있습니다.  

Storage Analytics는 검색할 로그 메시지가 포함된 Blob를 찾을 수 있도록 Blob에 대한 명명 규칙을 사용합니다. 예를 들어 "queue/2014/07/31/1800/000001.log"라는 Blob에는 2014년 7월 31일 오후 6시 이후의 큐 서비스와 관련된 로그 메시지가 들어 있습니다. "000001"은 이것이 이 기간 동안의 첫 번째 로그 파일임을 나타냅니다. 또한 Storage Analytics는 파일에 저장된 첫 번째 및 마지막 로그 메시지의 타임스탬프를 Blob 메타데이터의 일부로 기록합니다. Blob Storage용 API를 사용하면 이름 접두사를 기반으로 컨테이너에서 Blob를 찾을 수 있습니다. 오후 6시 이후의 큐 로그 데이터가 들어 있는 모든 Blob를 찾으려면 접두사 &quot;queue/2014/07/31/1800&quot;을 사용하면 됩니다.  

저장소 분석은 로그 메시지를 내부적으로 버퍼링한 다음, 해당 Blob을 주기적으로 업데이트하거나 최신 로그 항목 집합으로 새 Blob을 만듭니다. 이는 Blob 서비스에 수행해야 하는 쓰기 수를 줄여 줍니다.  

사용자 고유의 응용 프로그램에서 이와 유사한 솔루션을 구현하는 경우 안정성(모든 로그 항목을 Blob Storage에 쓰기), 비용 및 확장성(응용 프로그램의 업데이트 버퍼링 및 Blob Storage에 일괄 작업으로 쓰기) 간의 장단점을 관리할 방법을 고려해야 합니다.  

#### <a name="issues-and-considerations"></a>문제 및 고려 사항
로그 데이터를 저장할 방법을 결정할 때 다음 사항을 고려하세요.  

* 잠재적 핫 파티션을 방지하는 테이블 디자인을 만든 경우 로그 데이터에 효율적으로 액세스할 수 없는 경우가 있을 수 있습니다.  
* 로그 데이터를 처리하기 위해 클라이언트에서 많은 레코드를 로드해야 하는 경우가 종종 있습니다.  
* 로그 데이터는 구조화된 경우가 많지만 Blob Storage가 더 나은 솔루션일 수 있습니다.  

### <a name="implementation-considerations"></a>구현 고려 사항
이 섹션에서는 이전 섹션에 설명된 패턴을 구현할 때 염두에 두어야 하는 몇 가지 고려 사항을 알아봅니다. 이 섹션에서는 대부분 Storage 클라이언트 라이브러리(이 문서 작성 당시 버전 4.3.0)를 사용하는 C#으로 작성된 예제를 사용합니다.  

### <a name="retrieving-entities"></a>엔터티 검색
[쿼리를 위한 디자인](#design-for-querying)섹션에 설명된 대로 가장 효율적인 쿼리는 지점 쿼리입니다. 그러나 일부 시나리오에서는 여러 엔터티를 검색해야 할 수 있습니다. 이 섹션에서는 Storage 클라이언트 라이브러리를 사용하여 엔터티를 검색하는 몇 가지 일반적인 접근 방식을 설명합니다.  

#### <a name="executing-a-point-query-using-the-storage-client-library"></a>Storage 클라이언트 라이브러리를 사용하여 지점 쿼리 실행
지점 쿼리를 실행하는 가장 간편한 방법은 **PartitionKey** 값이 "Sales"이고 **RowKey** 값이 "212"인 엔터티를 검색하는 **Retrieve** 테이블 작업을 다음 C# 코드 조각에 표시된 대로 사용하는 것입니다.  

```csharp
TableOperation retrieveOperation = TableOperation.Retrieve<EmployeeEntity>("Sales", "212");
var retrieveResult = employeeTable.Execute(retrieveOperation);
if (retrieveResult.Result != null)
{
    EmployeeEntity employee = (EmployeeEntity)retrieveResult.Result;
    ...
}  
```

이 예제에서는 검색할 엔터티의 형식이 **EmployeeEntity**인 것으로 가정합니다.  

#### <a name="retrieving-multiple-entities-using-linq"></a>LINQ를 사용하여 여러 엔터티 검색
Storage 클라이언트 라이브러리와 함께 LINQ를 사용하고 **where** 절이 있는 쿼리를 지정하여 여러 엔터티를 검색할 수 있습니다. 테이블 스캔을 방지하려면 항상 where 절에 **PartitionKey** 값을 포함해야 하며, 가능한 경우 **RowKey** 값을 포함하여 테이블 및 파티션 스캔을 방지해야 합니다. 테이블 서비스에서는 where 절에 사용할 수 있는 비교 연산자 집합(보다 큼, 보다 크거나 같음, 보다 작음, 보다 작거나 같음, 같음 및 같지 않음)이 제한되어 있습니다. 다음 C# 코드 조각은 영업 부서(**PartitionKey**에 부서 이름이 저장되어 있는 것으로 가정)에서 성이 "B"(**RowKey**에 성이 저장되어 있는 것으로 가정)로 시작하는 모든 직원을 찾습니다.  

```csharp
TableQuery<EmployeeEntity> employeeQuery = employeeTable.CreateQuery<EmployeeEntity>();
var query = (from employee in employeeQuery
            where employee.PartitionKey == "Sales" &&
            employee.RowKey.CompareTo("B") >= 0 &&
            employee.RowKey.CompareTo("C") < 0
            select employee).AsTableQuery();
var employees = query.Execute();  
```

더 나은 성능을 위해 쿼리에서 **RowKey** 및 **PartitionKey**를 둘 다 지정합니다.  

다음 코드 예제에서는 흐름 API를 사용하여 동일한 기능을 보여 줍니다(일반적인 흐름 API에 대한 자세한 내용은 [흐름 API 디자인 모범 사례](https://visualstudiomagazine.com/articles/2013/12/01/best-practices-for-designing-a-fluent-api.aspx)참조).  

```csharp
TableQuery<EmployeeEntity> employeeQuery = new TableQuery<EmployeeEntity>().Where(
    TableQuery.CombineFilters(
    TableQuery.CombineFilters(
        TableQuery.GenerateFilterCondition(
    "PartitionKey", QueryComparisons.Equal, "Sales"),
    TableOperators.And,
    TableQuery.GenerateFilterCondition(
    "RowKey", QueryComparisons.GreaterThanOrEqual, "B")
),
TableOperators.And,
TableQuery.GenerateFilterCondition("RowKey", QueryComparisons.LessThan, "C")
    )
);
var employees = employeeTable.ExecuteQuery(employeeQuery);  
```

> [!NOTE]
> 이 샘플에서는 세 가지 필터 조건을 포함하기 위해 여러 **CombineFilters** 메서드를 중첩합니다.  
> 
> 

#### <a name="retrieving-large-numbers-of-entities-from-a-query"></a>쿼리에서 여러 엔터티 검색
최적의 쿼리는 **PartitionKey** 값과 **RowKey** 값을 기반으로 개별 엔터티를 반환합니다. 그러나 일부 시나리오에서는 동일한 파티션 또는 여러 파티션에서 여러 엔터티를 반환해야 하는 요구 사항이 있을 수 있습니다.  

이러한 시나리오에서는 항상 애플리케이션의 성능을 철저히 테스트해야 합니다.  

테이블 서비스에 대한 쿼리는 한 번에 최대 1,000개의 엔터티를 반환할 수 있으며, 최대 5초 동안 실행할 수 있습니다. 결과 집합에 1,000개가 넘는 엔터티가 포함되거나, 쿼리가 5초 이내에 완료되지 않거나, 쿼리가 파티션 경계를 넘은 경우 Table 서비스는 클라이언트 애플리케이션이 다음 엔터티 집합을 요청할 수 있도록 연속 토큰을 반환합니다. 연속 토큰의 작동 방식에 대한 자세한 내용은 [쿼리 제한 시간 및 페이지 번호 매김](https://msdn.microsoft.com/library/azure/dd135718.aspx)을 참조하세요.  

Storage 클라이언트 라이브러리를 사용하는 경우 Table service에서 엔터티를 반환할 때 연속 토큰을 자동으로 처리할 수 있습니다. Storage 클라이언트 라이브러리를 사용하는 다음 C# 코드 예제는 테이블 서비스가 응답으로 반환하는 연속 토큰을 자동으로 처리합니다.  

```csharp
string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);

var employees = employeeTable.ExecuteQuery(employeeQuery);
foreach (var emp in employees)
{
        ...
}  
```

다음 C# 코드는 연속 토큰을 명시적으로 처리합니다.  

```csharp
string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);

TableContinuationToken continuationToken = null;

do
{
        var employees = employeeTable.ExecuteQuerySegmented(
        employeeQuery, continuationToken);
    foreach (var emp in employees)
    {
    ...
    }
    continuationToken = employees.ContinuationToken;
} while (continuationToken != null);  
```

연속 토큰을 명시적으로 사용하면 애플리케이션이 데이터의 다음 세그먼트를 검색하는 시점을 제어할 수 있습니다. 예를 들어 클라이언트 애플리케이션이 테이블에 저장된 엔터티의 페이징을 지원하는 경우, 사용자는 쿼리에서 검색된 일부 엔터티를 페이징하지 않도록 결정하여 현재 세그먼트의 모든 엔터티에 대한 페이징을 완료했을 때 애플리케이션이 연속 토큰만을 사용하여 다음 세그먼트를 검색하도록 할 수 있습니다. 이 접근 방식에는 몇 가지 이점이 있습니다.  

* Table service에서 검색할 데이터의 양을 제한하고 네트워크를 통해 이동할 수 있습니다.  
* .NET에서 비동기 IO를 수행할 수 있습니다.  
* 연속 토큰을 영구 스토리지에 직렬화하여 애플리케이션의 작동이 중단된 경우에도 작업을 계속할 수 있습니다.  

> [!NOTE]
> 일반적으로 연속 토큰은 1,000개(이보다 적을 수도 있음)의 엔터티가 포함된 세그먼트를 반환합니다. 이는 **수행**을 사용해 쿼리에서 반환되는 항목 수를 제한하여 조회 조건과 일치하는 첫 번째 n개의 엔터티를 반환하도록 한 경우에도 마찬가지입니다. Table service는 나머지 엔터티를 검색할 수 있도록 연속 토큰과 함께 n개 미만의 엔터티가 포함된 세그먼트를 반환할 수 있습니다.  
> 
> 

다음 C# 코드에서는 세그먼트 내에서 반환되는 엔터티 수를 수정하는 방법을 보여 줍니다.  

```csharp
employeeQuery.TakeCount = 50;  
```

#### <a name="server-side-projection"></a>서버 쪽 프로젝션
단일 엔터티는 최대 255개의 속성을 가질 수 있으며, 크기가 최대 1MB일 수 있습니다. 테이블을 쿼리하여 엔터티를 검색할 때 필요 없는 속성을 제외하여 데이터가 불필요하게 전송되는 것을 방지할 수 있습니다(이 경우 대기 시간이 단축되고 비용이 절감됨). 서버 쪽 프로젝션을 사용하여 필요한 속성만 전송할 수 있습니다. 다음 예제에서는 쿼리에서 선택한 엔터티에서 **Email** 속성만(**PartitionKey**, **RowKey**, **Timestamp** 및 **ETag**와 함께) 검색합니다.  

```csharp
string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
List<string> columns = new List<string>() { "Email" };
TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter).Select(columns);

var entities = employeeTable.ExecuteQuery(employeeQuery);
foreach (var e in entities)
{
        Console.WriteLine("RowKey: {0}, EmployeeEmail: {1}", e.RowKey, e.Email);
}  
```

**RowKey** 값은 검색할 속성 목록에 포함되지 않은 경우에도 사용할 수 있습니다.  

### <a name="modifying-entities"></a>엔터티 수정
Storage 클라이언트 라이브러리를 사용하면 엔터티를 삽입, 삭제 및 업데이트하여 테이블 서비스에 저장된 엔터티를 수정할 수 있습니다. EGT를 사용하면 여러 삽입, 업데이트 및 삭제 작업을 일괄적으로 수행하여 필요한 왕복 횟수를 줄이고 솔루션의 성능을 향상시킬 수 있습니다.  

Storage 클라이언트 라이브러리에서 EGT를 실행할 때 발생하는 예외에는 일반적으로 일괄 처리가 실패하도록 하는 엔터티의 인덱스가 포함됩니다. 이는 EGT를 사용하는 코드를 디버그할 때 유용합니다.  

디자인이 클라이언트 애플리케이션에서 동시성 및 업데이트 작업을 처리하는 방법에 어떤 영향을 미치는지도 고려해야 합니다.  

#### <a name="managing-concurrency"></a>동시성 관리
기본적으로 클라이언트가 Table service에서 이러한 확인을 강제로 무시하도록 할 수도 있지만 Table service는 개별 엔터티 수준에서 **삽입**, **병합** 및 **삭제** 작업에 대한 낙관적 동시성 확인을 구현합니다. Table service에서 동시성을 관리하는 방법에 대한 자세한 내용은 [Microsoft Azure Storage에서 동시성 관리](../storage/common/storage-concurrency.md)를 참조하세요.  

#### <a name="merge-or-replace"></a>병합 또는 바꾸기
**TableOperation** 클래스의 **바꾸기** 메서드는 항상 Table service의 전체 엔터티를 바꿉니다. 저장된 엔터티에 존재하는 속성을 포함하지 않으면 요청 시 저장된 엔터티에서 해당 속성이 제거됩니다. 저장된 엔터티에서 속성을 명시적으로 제거하지 않은 한 모든 속성을 요청에 포함해야 합니다.  

엔터티를 업데이트할 때 **TableOperation** 클래스의 **병합** 메서드를 사용하여 Table service로 보낼 데이터의 양을 줄일 수 있습니다. **병합** 메서드는 저장된 엔터티의 모든 속성을 요청에 포함된 엔터티의 속성 값으로 바꾸지만 요청에 포함되지 않은 속성은 저장된 엔터티에 그대로 유지합니다. 이는 엔터티가 많을 때 요청에서 소수의 속성만 업데이트해야 하는 경우에 유용합니다.  

> [!NOTE]
> 엔터티가 존재하지 않으면 **바꾸기** 및 **병합** 메서드가 실패합니다. 또는 엔터티가 존재하지 않는 경우 새 엔터티를 만드는 **InsertOrReplace** 및 **InsertOrMerge** 메서드를 사용할 수 있습니다.  
> 
> 

### <a name="working-with-heterogeneous-entity-types"></a>유형이 다른 엔터티 유형 작업
Table service는 *스키마가 없는* 테이블 저장소이며 이는 단일 테이블이 뛰어난 디자인 유연성을 제공하는 여러 형식의 엔터티를 저장할 수 있다는 것을 의미합니다. 다음 예제에서는 직원 및 부서 엔터티를 모두 저장하는 테이블을 보여 줍니다.  

<table>
<tr>
<th>PartitionKey</th>
<th>RowKey</th>
<th>타임 스탬프</th>
<th></th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>Email</th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>Email</th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>DepartmentName</th>
<th>EmployeeCount</th>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>Email</th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
</table>

각 엔터티에 여전히 **PartitionKey**, **RowKey** 및 **Timestamp** 값이 있어야 하지만 다른 속성 집합은 원하는 대로 포함할 수 있습니다. 또한 해당 정보를 저장하도록 선택하지 않은 경우 엔터티 유형을 나타내는 항목이 없습니다. 엔터티 유형을 식별하는 두 가지 옵션이 있습니다.  

* **RowKey**(또는 **PartitionKey**) 앞에 엔터티 형식을 추가합니다. **RowKey** 값을 예로 들어 **EMPLOYEE_000123** 또는 **DEPARTMENT_SALES**하십시오.  
* 아래 표에 표시된 대로 별도의 속성을 사용하여 엔터티 유형을 기록합니다.  

<table>
<tr>
<th>PartitionKey</th>
<th>RowKey</th>
<th>타임 스탬프</th>
<th></th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>EntityType</th>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>Email</th>
</tr>
<tr>
<td>Employee</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>EntityType</th>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>Email</th>
</tr>
<tr>
<td>Employee</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>EntityType</th>
<th>DepartmentName</th>
<th>EmployeeCount</th>
</tr>
<tr>
<td>department</td>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>EntityType</th>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>Email</th>
</tr>
<tr>
<td>Employee</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
</table>

**RowKey**앞에 엔터티 유형을 추가하는 첫 번째 옵션은 유형이 서로 다른 두 엔터티의 키 값이 동일할 수 있는 경우에 유용합니다. 또한 이 옵션은 동일한 유형의 엔터티를 파티션에서 그룹화합니다.  

이 섹션에 설명된 기술은 특히 이 가이드 앞부분에 나오는 관계 모델링 섹션의 [상속 관계](#inheritance-relationships)와 관련이 있습니다.  

> [!NOTE]
> 클라이언트 애플리케이션이 POCO 개체를 구체화하고 여러 버전에서 작동하도록 하려면 엔터티 유형 값에 버전 번호를 포함해야 합니다.  
> 
> 

이 섹션의 나머지 부분에서는 동일한 테이블의 여러 엔터티 유형으로 작업하는 데 용이한 Storage 클라이언트 라이브러리의 몇 가지 기능에 대해 설명합니다.  

#### <a name="retrieving-heterogeneous-entity-types"></a>서로 다른 엔터티 유형 검색
Storage 클라이언트 라이브러리를 사용하는 경우 여러 엔터티 유형으로 작업하는 세 가지 옵션이 있습니다.  

특정 **RowKey** 및 **PartitionKey** 값과 함께 저장된 엔터티의 유형을 알고 있는 경우에는 유형이 **EmployeeEntity**인 엔터티를 검색하는 이전 두 예제([Storage 클라이언트 라이브러리를 사용하여 지점 쿼리 실행](#executing-a-point-query-using-the-storage-client-library) 및 [LINQ를 사용하여 여러 엔터티 검색](#retrieving-multiple-entities-using-linq))와 같이 엔터티를 검색할 때 엔터티 유형을 지정할 수 있습니다.  

두 번째 옵션은 구체적 POCO 엔터티 형식 대신 **DynamicTableEntity** 형식(속성 모음)을 사용하는 것입니다(이 옵션을 사용하면 엔터티를 .NET 형식으로 직렬화 및 역직렬화할 필요가 없으므로 성능이 향상될 수도 있습니다). 다음 C# 코드는 잠재적으로 테이블에서 다양한 형식의 여러 엔터티를 검색하지만 모든 엔터티를 **DynamicTableEntity** 인스턴스로 반환합니다. 그런 다음 **EntityType** 속성을 사용하여 각 엔터티의 형식을 확인합니다.  

```csharp
string filter = TableQuery.CombineFilters(
    TableQuery.GenerateFilterCondition("PartitionKey",
    QueryComparisons.Equal, "Sales"),
    TableOperators.And,
    TableQuery.CombineFilters(
    TableQuery.GenerateFilterCondition("RowKey",
                    QueryComparisons.GreaterThanOrEqual, "B"),
        TableOperators.And,
        TableQuery.GenerateFilterCondition("RowKey",
        QueryComparisons.LessThan, "F")
    )
);
TableQuery<DynamicTableEntity> entityQuery =
    new TableQuery<DynamicTableEntity>().Where(filter);
var employees = employeeTable.ExecuteQuery(entityQuery);

IEnumerable<DynamicTableEntity> entities = employeeTable.ExecuteQuery(entityQuery);
foreach (var e in entities)
{
EntityProperty entityTypeProperty;
if (e.Properties.TryGetValue("EntityType", out entityTypeProperty))
{
    if (entityTypeProperty.StringValue == "Employee")
    {
        // Use entityTypeProperty, RowKey, PartitionKey, Etag, and Timestamp
        }
    }
}  
```

다른 속성을 검색하려면 **DynamicTableEntity** 클래스의 **Properties** 속성에서 **TryGetValue** 메서드를 사용해야 합니다.  

세 번째 옵션은 **DynamicTableEntity** 유형과 **EntityResolver** 인스턴스를 함께 사용하는 것입니다. 이 옵션을 사용하면 동일한 쿼리에서 여러 POCO 유형을 확인할 수 있습니다. 이 예제에서 **EntityResolver** 대리자가 **EntityType** 속성을 사용하여 쿼리에서 반환된 엔터티의 두 가지 형식을 구분합니다. **Resolve** 메서드는 **resolver** 대리자를 사용하여 **DynamicTableEntity** 인스턴스를 **TableEntity** 인스턴스에 확인합니다.  

```csharp
EntityResolver<TableEntity> resolver = (pk, rk, ts, props, etag) =>
{

        TableEntity resolvedEntity = null;
        if (props["EntityType"].StringValue == "Department")
        {
        resolvedEntity = new DepartmentEntity();
        }
        else if (props["EntityType"].StringValue == "Employee")
        {
        resolvedEntity = new EmployeeEntity();
        }
        else throw new ArgumentException("Unrecognized entity", "props");

        resolvedEntity.PartitionKey = pk;
        resolvedEntity.RowKey = rk;
        resolvedEntity.Timestamp = ts;
        resolvedEntity.ETag = etag;
        resolvedEntity.ReadEntity(props, null);
        return resolvedEntity;
};

string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
TableQuery<DynamicTableEntity> entityQuery =
        new TableQuery<DynamicTableEntity>().Where(filter);

var entities = employeeTable.ExecuteQuery(entityQuery, resolver);
foreach (var e in entities)
{
        if (e is DepartmentEntity)
        {
    ...
        }
        if (e is EmployeeEntity)
        {
    ...
        }
}  
```

#### <a name="modifying-heterogeneous-entity-types"></a>서로 다른 엔터티 유형 수정
엔터티를 삭제할 때는 엔터티 유형을 몰라도 되지만 엔터티를 삽입할 때는 항상 엔터티 유형을 알아야 합니다. 그러나 **DynamicTableEntity** 형식을 사용하면 형식을 모르는 경우에도 POCO 엔터티 클래스를 사용하지 않고 엔터티를 업데이트할 수 있습니다. 다음 코드 샘플에서는 단일 엔터티를 검색하여 업데이트하기 전에 **EmployeeCount** 속성이 있는지 확인합니다.  

```csharp
TableResult result =
        employeeTable.Execute(TableOperation.Retrieve(partitionKey, rowKey));
DynamicTableEntity department = (DynamicTableEntity)result.Result;

EntityProperty countProperty;

if (!department.Properties.TryGetValue("EmployeeCount", out countProperty))
{
        throw new
        InvalidOperationException("Invalid entity, EmployeeCount property not found.");
}
countProperty.Int32Value += 1;
employeeTable.Execute(TableOperation.Merge(department));  
```

### <a name="controlling-access-with-shared-access-signatures"></a>공유 액세스 서명을 사용하여 액세스 제어
SAS(공유 액세스 서명) 토큰을 사용하여 클라이언트 애플리케이션이 테이블 서비스에 직접 인증하지 않고도 테이블 엔터티를 직접 수정(및 쿼리)하도록 할 수 있습니다. 일반적으로 애플리케이션응에서 SAS를 사용할 경우 세 가지 주요 이점이 있습니다.  

* 해당 디바이스가 Table service의 엔터티에 액세스하고 수정할 수 있도록 하기 위해 보안되지 않는 플랫폼(예: 모바일 디바이스)에 저장소 계정 키를 배포할 필요가 없습니다.  
* 웹 및 작업자 역할이 엔터티를 관리하면서 수행하는 일부 작업을 최종 사용자 컴퓨터 및 모바일 디바이스와 같은 클라이언트 디바이스로 오프로드할 수 있습니다.  
* 제약적이고 시간 제한된 권한 집합(예: 특정 리소스에 대한 읽기 전용 액세스 허용)을 클라이언트에 할당할 수 있습니다.  

Table service에서 SAS 토큰 사용에 대한 자세한 내용은 [SAS(공유 액세스 서명) 사용](../storage/common/storage-dotnet-shared-access-signature-part-1.md)을 참조하세요.  

그러나 클라이언트 애플리케이션에 테이블 서비스의 엔터티에 대한 권한을 부여하는 SAS 토큰을 여전히 생성해야 합니다. 저장소 계정 키에 대한 보안 액세스가 있는 환경에서 이 작업을 수행합니다. 일반적으로 웹 또는 작업자 역할을 사용하여 SAS 토큰을 생성하고 엔터티에 액세스해야 하는 클라이언트 애플리케이션에 이를 제공합니다. SAS 토큰을 생성하여 클라이언트에 제공하는 작업과 관련된 오버헤드가 여전히 있으므로 특히 대용량 시나리오에서 이 오버헤드를 줄일 수 있는 최상의 방법을 고려해야 합니다.  

테이블에 있는 엔터티의 하위 집합에 대한 액세스 권한을 부여하는 SAS 토큰을 생성할 수 있습니다. 기본적으로 전체 테이블에 대한 SAS 토큰을 만들지만 이 SAS 토큰이 **PartitionKey** 값 범위 또는 **PartitionKey** 및 **RowKey** 값 범위에 대한 액세스 권한을 부여하도록 지정할 수도 있습니다. 각 사용자의 SAS 토큰이 Table service에 있는 해당 사용자의 고유 엔터티에 대한 액세스만 허용하도록 시스템의 개별 사용자에 대한 SAS 토큰을 생성할 수 있습니다.  

### <a name="asynchronous-and-parallel-operations"></a>비동기 및 병렬 작업
여러 파티션에 요청을 분산하는 경우 비동기 또는 병렬 쿼리를 사용하여 처리량 및 클라이언트 응답성을 향상시킬 수 있습니다.
예를 들어 둘 이상의 작업자 역할 인스턴스에서 테이블에 병렬로 액세스하는 경우가 있을 수 있습니다. 특정 파티션 집합을 담당하는 개별 작업자 역할을 두거나, 여러 작업자 역할 인스턴스에서 각각 테이블의 모든 파티션에 액세스할 수 있도록 할 수 있습니다.  

클라이언트 인스턴스 내에서 저장소 작업을 비동기식으로 실행하여 처리량을 향상시킬 수 있습니다. Storage 클라이언트 라이브러리를 사용하면 비동기 쿼리 및 수정 사항을 쉽게 작성할 수 있습니다. 예를 들어 다음 C# 코드와 같이 파티션의 모든 엔터티를 검색하는 동기 메서드로 시작할 수 있습니다.  

```csharp
private static void ManyEntitiesQuery(CloudTable employeeTable, string department)
{
        string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, department);
        TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);

        TableContinuationToken continuationToken = null;

        do
        {
        var employees = employeeTable.ExecuteQuerySegmented(
                employeeQuery, continuationToken);
        foreach (var emp in employees)
    {
        ...
    }
        continuationToken = employees.ContinuationToken;
        } while (continuationToken != null);
}  
```

그런 다음 쿼리가 비동기식으로 실행되도록 아래와 같이 이 코드를 쉽게 수정할 수 있습니다.  

```csharp
private static async Task ManyEntitiesQueryAsync(CloudTable employeeTable, string department)
{
        string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, department);
        TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);
        TableContinuationToken continuationToken = null;

        do
        {
        var employees = await employeeTable.ExecuteQuerySegmentedAsync(
                employeeQuery, continuationToken);
        foreach (var emp in employees)
        {
            ...
        }
        continuationToken = employees.ContinuationToken;
            } while (continuationToken != null);
}  
```

이 비동기 예제에서는 동기 버전에서 다음 사항이 변경된 것을 확인할 수 있습니다.  

* 이제 메서드 서명은 **async** 수정자를 포함하고 **Task** 인스턴스를 반환합니다.  
* **ExecuteSegmented** 메서드를 호출하여 결과를 검색하는 대신, 이제 메서드에서 **ExecuteSegmentedAsync** 메서드를 호출하고 **await** 한정자를 사용하여 결과를 비동기식으로 검색합니다.  

클라이언트 애플리케이션은(서로 다른 **department** 매개 변수 값)이 메서드를 여러 번 호출할 수 있으며, 각 쿼리는 별도의 스레드에서 실행됩니다.  

**TableQuery** 클래스의 **Execute** 메서드는 비동기 버전이 없습니다. **IEnumerable** 인터페이스가 비동기 열거형을 지원하지 않기 때문입니다.  

엔터티를 비동기식으로 삽입, 업데이트 및 삭제할 수도 있습니다. 다음 C# 예제에서는 직원 엔터티를 삽입하거나 바꾸는 간단한 동기 메서드를 보여 줍니다.  

```csharp
private static void SimpleEmployeeUpsert(CloudTable employeeTable,
        EmployeeEntity employee)
{
        TableResult result = employeeTable
        .Execute(TableOperation.InsertOrReplace(employee));
        Console.WriteLine("HTTP Status: {0}", result.HttpStatusCode);
}  
```

업데이트가 비동기식으로 실행되도록 아래와 같이 이 코드를 쉽게 수정할 수 있습니다.  

```csharp
private static async Task SimpleEmployeeUpsertAsync(CloudTable employeeTable,
        EmployeeEntity employee)
{
        TableResult result = await employeeTable
        .ExecuteAsync(TableOperation.InsertOrReplace(employee));
        Console.WriteLine("HTTP Status: {0}", result.HttpStatusCode);
}  
```

이 비동기 예제에서는 동기 버전에서 다음 사항이 변경된 것을 확인할 수 있습니다.  

* 이제 메서드 서명은 **async** 수정자를 포함하고 **Task** 인스턴스를 반환합니다.  
* **Execute** 메서드를 호출하여 엔터티를 업데이트하는 대신, 이제 메서드에서 **ExecuteAsync** 메서드를 호출하고 **await** 한정자를 사용하여 결과를 비동기식으로 검색합니다.  

클라이언트 애플리케이션은 이와 같은 여러 비동기 메서드를 호출할 수 있으며, 각 메서드 호출은 별도의 스레드에서 실행됩니다.  

### <a name="credits"></a>크레딧
도움을 주신 Azure 팀원인 Dominic Betts, Jason Hogg, Jean Ghanem, Jai Haridas, Jeff Irwin, Vamshidhar Kommineni, Vinay Shah, Serdar Ozler과 Microsoft DX의 Tom Hollander에게 감사드립니다. 

또한 검토 과정에서 소중한 의견을 제공해 주신 Microsoft MVP인 Igor Papirov 및 Edward Bakker에게도 감사드립니다.

[1]: ./media/storage-table-design-guide/storage-table-design-IMAGE01.png
[2]: ./media/storage-table-design-guide/storage-table-design-IMAGE02.png
[3]: ./media/storage-table-design-guide/storage-table-design-IMAGE03.png
[4]: ./media/storage-table-design-guide/storage-table-design-IMAGE04.png
[5]: ./media/storage-table-design-guide/storage-table-design-IMAGE05.png
[6]: ./media/storage-table-design-guide/storage-table-design-IMAGE06.png
[7]: ./media/storage-table-design-guide/storage-table-design-IMAGE07.png
[8]: ./media/storage-table-design-guide/storage-table-design-IMAGE08.png
[9]: ./media/storage-table-design-guide/storage-table-design-IMAGE09.png
[10]: ./media/storage-table-design-guide/storage-table-design-IMAGE10.png
[11]: ./media/storage-table-design-guide/storage-table-design-IMAGE11.png
[12]: ./media/storage-table-design-guide/storage-table-design-IMAGE12.png
[13]: ./media/storage-table-design-guide/storage-table-design-IMAGE13.png
[14]: ./media/storage-table-design-guide/storage-table-design-IMAGE14.png
[15]: ./media/storage-table-design-guide/storage-table-design-IMAGE15.png
[16]: ./media/storage-table-design-guide/storage-table-design-IMAGE16.png
[17]: ./media/storage-table-design-guide/storage-table-design-IMAGE17.png
[18]: ./media/storage-table-design-guide/storage-table-design-IMAGE18.png
[19]: ./media/storage-table-design-guide/storage-table-design-IMAGE19.png
[20]: ./media/storage-table-design-guide/storage-table-design-IMAGE20.png
[21]: ./media/storage-table-design-guide/storage-table-design-IMAGE21.png
[22]: ./media/storage-table-design-guide/storage-table-design-IMAGE22.png
[23]: ./media/storage-table-design-guide/storage-table-design-IMAGE23.png
[24]: ./media/storage-table-design-guide/storage-table-design-IMAGE24.png
[25]: ./media/storage-table-design-guide/storage-table-design-IMAGE25.png
[26]: ./media/storage-table-design-guide/storage-table-design-IMAGE26.png
[27]: ./media/storage-table-design-guide/storage-table-design-IMAGE27.png
[28]: ./media/storage-table-design-guide/storage-table-design-IMAGE28.png
[29]: ./media/storage-table-design-guide/storage-table-design-IMAGE29.png

