---
title: Azure Cosmos DB의 데이터베이스 트랜잭션 및 낙관적 동시성 제어
description: 이 문서는 Azure Cosmos DB의 데이터베이스 트랜잭션 및 낙관적 동시성 제어를 설명합니다.
author: rimman
ms.service: cosmos-db
ms.topic: conceptual
ms.date: 04/08/2019
ms.author: rimman
ms.reviewer: sngun
ms.openlocfilehash: 568f47aacf39793d4c2da46798682abc002ca33b
ms.sourcegitcommit: 3102f886aa962842303c8753fe8fa5324a52834a
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/23/2019
ms.locfileid: "60889358"
---
# <a name="transactions-and-optimistic-concurrency-control"></a>트랜잭션 및 낙관적 동시성 제어

데이터베이스 트랜잭션은 데이터에 대한 동시 변경을 처리하기 위한 안전하고 예측 가능한 프로그래밍 모델을 제공합니다. SQL Server와 같은 기존 관계형 데이터베이스, 데이터베이스 엔진 내에서 직접 실행에 대 한 서버에 보낼 저장 프로시저 및/또는 트리거를 사용 하 여 비즈니스 논리를 작성할 수 있습니다. (비트랜잭션) 응용 프로그램 프로그래밍 언어 Python, JavaScript 등 두 가지 다른 프로그래밍 언어를 사용 하 여 처리 하는 데 필요한는 전통적인 관계형 데이터베이스를 사용 하 여 C#를 등 Java 및 트랜잭션 프로그래밍 언어 ( T-SQL)와 같은 데이터베이스를 고유 하 게 실행 되는 합니다.

Azure Cosmos DB의 데이터베이스 엔진은 스냅숏 격리를 사용한 전체 ACID(원자성, 일관성, 격리, 내구성) 준수 트랜잭션을 지원합니다. 데이터베이스의 모든 작업 범위 내에서 컨테이너의 [논리 파티션을](partition-data.md) 파티션의 복제본을 호스팅하는 데이터베이스 엔진 내에서 트랜잭션으로 실행 됩니다. 이러한 작업은 쓰기(논리 파티션 내에서 하나 이상의 항목을 업데이트) 및 읽기 작업을 모두 포함합니다. 다음 표에서는 다양한 작업 및 트랜잭션 형식을 설명합니다.

| **작업**  | **작업 유형** | **단일 또는 다중 항목 트랜잭션** |
|---------|---------|---------|
| 삽입(사전/사후 트리거 없음) | 쓰기 | 단일 항목 트랜잭션 |
| 삽입(사전/사후 트리거 있음) | 쓰기 및 읽기 | 다중 항목 트랜잭션 |
| 바꾸기(사전/사후 트리거 없음) | 쓰기 | 단일 항목 트랜잭션 |
| 바꾸기(사전/사후 트리거 있음) | 쓰기 및 읽기 | 다중 항목 트랜잭션 |
| Upsert(사전/사후 트리거 없음) | 쓰기 | 단일 항목 트랜잭션 |
| Upsert(사전/사후 트리거 있음) | 쓰기 및 읽기 | 다중 항목 트랜잭션 |
| 삭제(사전/사후 트리거 없음) | 쓰기 | 단일 항목 트랜잭션 |
| 삭제(사전/사후 트리거 있음) | 쓰기 및 읽기 | 다중 항목 트랜잭션 |
| 저장 프로시저 실행 | 쓰기 및 읽기 | 다중 항목 트랜잭션 |
| 시스템이 병합 프로시저 실행을 시작함 | 쓰기 | 다중 항목 트랜잭션 |
| 시스템이 항목의 만료(TTL)를 기준으로 항목을 삭제 실행을 시작함 | 쓰기 | 다중 항목 트랜잭션 |
| 읽기 | 읽기 | 단일 항목 트랜잭션 |
| 피드 변경 | 읽기 | 다중 항목 트랜잭션 |
| 페이지를 매긴 읽기 | 읽기 | 다중 항목 트랜잭션 |
| 페이지를 매긴 쿼리 | 읽기 | 다중 항목 트랜잭션 |
| 페이지를 매긴 쿼리의 일부로 UDF 실행 | 읽기 | 다중 항목 트랜잭션 |

## <a name="multi-item-transactions"></a>다중 항목 트랜잭션

Azure Cosmos DB를 사용 하면 작성할 수 있습니다 [저장 프로시저, 사전/사후 트리거, 사용자 정의-함수 (Udf)](stored-procedures-triggers-udfs.md) 및 JavaScript의 절차를 병합 합니다. Azure Cosmos DB는 기본적으로 해당 데이터베이스 엔진 내에서 JavaScript 실행을 지원합니다. 저장 프로시저, 사전/사후 트리거, UDF(사용자 정의 함수) 및 병합 프로시저를 컨테이너에서 등록하고 나중에 Azure Cosmos 데이터베이스 엔진 내에 트랜잭션 방식으로 실행할 수 있습니다. JavaScript에서 애플리케이션 논리를 작성하면 제어 흐름, 변수 범위 지정, 할당 및 예외 처리 기본 형식의 통합을 JavaScript 언어로 직접 데이터베이스 트랜잭션 내에서 자연스럽게 표현할 수 있습니다.

JavaScript 기반 저장 프로시저, 트리거, UDF 및 병합 프로시저는 논리 파티션 내 모든 항목에서 스냅숏 격리를 사용하여 앰비언트 ACID 트랜잭션 내에서 래핑됩니다. 실행 도중에 JavaScript에서 예외가 발생하면 전체 트랜잭션이 중단되고 롤백됩니다. 결과로 생성된 프로그래밍 모델은 단순하지만 강력합니다. JavaScript 개발자는 익숙한 언어 구문과 라이브러리 기본 형식을 사용하면서 동시에 내구성 있는 프로그래밍 모델을 얻게 됩니다.

데이터베이스 엔진 내에서 직접 JavaScript를 실행할 수 있어 컨테이너의 항목에 대한 데이터베이스 작업의 트랜잭션 실행 및 성능을 제공합니다. 또한 Azure Cosmos 데이터베이스 엔진은 기본적으로 JSON 및 JavaScript를 지원하므로 애플리케이션과 데이터베이스의 형식 시스템 간 불일치가 제거됩니다.

## <a name="optimistic-concurrency-control"></a>낙관적 동시성 제어 

낙관적 동시성 제어를 통해 업데이트 손실 및 삭제를 방지할 수 있습니다. 충돌하는 동시 작업은 항목을 소유하는 논리 파티션에서 호스팅된 데이터베이스 엔진의 일반 비관적 잠금에 종속됩니다. 두 개의 동시 작업이 논리 파티션 내 항목의 최신 버전을 업데이트하려고 하면 두 작업 중 하나는 성공하고 다른 하나는 실패합니다. 그러나 동일한 항목을 동시에 업데이트하려는 하나 또는 두 개의 작업에서 이전에 항목의 이전 값을 읽은 경우, 데이터베이스는 충돌하는 하나 또는 두 개의 작업의 이전 읽기 값이 실제로 항목의 최신 값인지 알지 못합니다. 다행히이 이런 발견 될 수 있습니다 합니다 **낙관적 동시성 제어 (OCC)** 두 작업 수 있도록 하기 전에 데이터베이스 엔진 내에서 트랜잭션 경계를 입력 합니다. OCC는 다른 사용자가 수행한 변경 내용을 실수로 덮어쓰지 않도록 데이터를 보호합니다. 또한 자신의 변경 내용을 실수로 덮어쓰지 않도록 다른 사용자를 보호합니다.

항목의 동시 업데이트는 Azure Cosmos DB의 통신 프로토콜 계층에 의한 OCC에 종속됩니다. Azure Cosmos 데이터베이스는 사용자는 업데이트(또는 삭제)하는 항목의 클라이언트 쪽 버전이 Azure Cosmos 컨테이너의 항목 버전과 동일한지 확인합니다. 그러면 사용자의 쓰기가 실수로 다른 사용자의 쓰기로 덮어쓰이거나 그 반대의 경우가 발생하지 않도록 방지할 수 있습니다. 다중 사용자 환경에서 낙관적 동시성 제어는 항목의 잘못된 버전이 실수로 삭제 또는 업데이트되지 않도록 보호합니다. 따라서 악명 높은 “업데이트 손실” 또는 “삭제 손실” 문제로부터 항목이 보호됩니다.

Azure Cosmos 컨테이너에 저장된 모든 항목에는 시스템 정의 `_etag` 속성이 있습니다. `_etag`의 값이 자동으로 생성되고, 항목이 업데이트될 때마다 서버에서 업데이트됩니다. `_etag` 사용 하 여 클라이언트가 제공한 `if-match` 요청 헤더를 서버에서 항목을 조건에 따라 업데이트할 수 있는지 여부를 결정할 수 있도록 합니다. 값을 `if-match` 헤더의 값과 일치는 `_etag` 항목의 다음 서버에서 업데이트 합니다. 경우의 값을 `if-match` 요청 헤더는 현재 더 이상에서 사용 하 여 작업을 취소 하는 서버는 "HTTP 412 사전 조건 실패" 응답 메시지입니다. 클라이언트 수 다시 가져올 수는 서버에 있는 항목의 현재 버전을 획득 하거나 서버 자체에 항목의 버전을 재정의 항목 `_etag` 항목 값입니다. 또한 `_etag` 와 함께 사용할 수는 `if-none-match` 리소스를 다시 인출 하는 필요한 지 여부를 결정 하는 헤더입니다. 

항목의 `_etag` 항목이 업데이트 될 때마다 값이 변경 합니다. 대체 항목 작업에 대 한 `if-match` 요청 옵션의 일부로 명시적으로 나타내야 합니다. 예제는 [GitHub](https://github.com/Azure/azure-documentdb-dotnet/blob/master/samples/code-samples/DocumentManagement/Program.cs#L398-L446)의 샘플 코드를 참조하세요. `_etag` 값은 저장된 프로시저에서 모든 기록된 항목에 대 한 암시적으로 검사 됩니다. 충돌이 감지 되 면 저장된 프로시저를 트랜잭션을 롤백하고 예외를 throw 합니다. 이 메서드를 사용하면 저장 프로시저 내에서 전체 쓰기 또는 쓰기 없음이 자동으로 적용됩니다. 이는 애플리케이션이 업데이트를 다시 적용하고 원래 클라이언트 요청을 다시 시도하기 위한 신호입니다.

## <a name="next-steps"></a>다음 단계

다음 문서에서 데이터베이스 트랜잭션 및 낙관적 동시성 제어에 대해 자세히 알아보세요.

- [Azure Cosmos 데이터베이스, 컨테이너 및 항목 작업](databases-containers-items.md)
- [일관성 수준](consistency-levels.md)
- [충돌 유형 및 해결 정책](conflict-resolution-policies.md)
- [저장된 프로시저, 트리거 및 사용자 정의 함수](stored-procedures-triggers-udfs.md)
