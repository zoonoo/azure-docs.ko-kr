---
title: 장애 조치(failover) 및 패치 - Azure Cache for Redis
description: Azure Cache for Redis를 위한 장애 조치(failover), 패치 및 업데이트 프로세스에 대해 알아봅니다.
author: yegu-ms
ms.author: yegu
ms.service: cache
ms.topic: conceptual
ms.date: 10/18/2019
ms.openlocfilehash: 91c62faf53bd0a0f81322316e5225579eaa6ca9d
ms.sourcegitcommit: a434cfeee5f4ed01d6df897d01e569e213ad1e6f
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 06/09/2021
ms.locfileid: "111813053"
---
# <a name="failover-and-patching-for-azure-cache-for-redis"></a>Azure Cache for Redis를 위한 장애 조치(failover) 및 패치

복원력 있고 성공적인 클라이언트 애플리케이션을 빌드하려면 Azure Cache for Redis 서비스의 장애 조치(failover)를 이해하는 것이 중요합니다. 장애 조치(failover)는 계획된 관리 작업의 일부이거나 계획되지 않은 하드웨어 또는 네트워크 오류로 인해 발생할 수 있습니다. 캐시 장애 조치(failover)의 일반적인 사용은 관리 서비스가 Azure Cache for Redis 이진을 패치할 때 발생합니다.

이 문서에서는 다음 정보를 찾을 수 있습니다.  

- 장애 조치(failover)란?
- 패치하는 동안 장애 조치(failover)가 발생하는 방식.
- 복원력 있는 클라이언트 애플리케이션을 빌드하는 방법.

## <a name="what-is-a-failover"></a>장애 조치(failover)란?

Azure Cache for Redis를 위한 장애 조치(failover)의 개요부터 살펴보겠습니다.

### <a name="a-quick-summary-of-cache-architecture"></a>캐시 아키텍처의 빠른 요약

캐시는 별도의 개인 IP 주소를 가진 여러 가상 머신으로 구성됩니다. 노드라고도 하는 각 가상 머신은 단일 가상 IP 주소를 사용하여 공유 부하 분산 장치에 연결됩니다. 각 노드는 Redis 서버 프로세스를 실행하며 호스트 이름 및 Redis 포트를 사용하여 액세스할 수 있습니다. 각 노드는 주 노드 또는 복제본 노드로 간주됩니다. 클라이언트 애플리케이션이 캐시에 연결되면 해당 트래픽은 이 부하 분산 장치를 통과하고 자동으로 주 노드로 라우팅됩니다.

기본 캐시에서 단일 노드는 항상 주 노드입니다. 표준 또는 프리미엄 캐시에는 두 개의 노드가 있습니다. 하나는 주 노드로 선택되고 다른 하나는 복제본입니다. 표준 및 프리미엄 캐시에는 여러 노드가 있으므로 한 노드를 사용할 수 없는 경우에도 다른 노드는 요청을 계속 처리할 수 있습니다. 클러스터형 캐시는 각각 고유한 주 노드와 복제본 노드가 있는 여러 분할된 데이터베이스로 구성됩니다. 하나의 분할된 데이터베이스는 다운되고 다른 분할된 데이터베이스는 계속 사용할 수 있습니다.

> [!NOTE]
> 기본 캐시에는 여러 노드가 없으며 가용성에 대한 SLA(서비스 수준 약정)를 제공하지 않습니다. 기본 캐시는 개발 및 테스트 목적으로만 권장됩니다. 다중 노드 배포에 표준 또는 프리미엄 캐시를 사용하여 가용성을 높입니다.

### <a name="explanation-of-a-failover"></a>장애 조치(failover) 설명

장애 조치(failover)는 복제본 노드가 자체적으로 주 노드로 승격시키고 이전 주 노드가 기존 연결을 닫을 때 발생합니다. 주 노드가 다시 나타나면 역할의 변경 사항을 인식하고 자체적으로 복제본으로 강등됩니다. 그런 다음, 새로운 주 노드에 연결하고 데이터를 동기화합니다. 장애 조치(failover)는 계획되거나 계획되지 않을 수 있습니다.

*계획된 장애 조치(failover)* 는 다음과 같은 두 경우에 수행됩니다.

- Redis 패치 또는 OS 업그레이드와 같은 시스템 업데이트  
- 크기 조정 및 다시 부팅과 같은 관리 작업

노드는 업데이트에 대한 사전 알림을 받기 때문에 역할을 협조적으로 교환하고 변경되는 부하 분산 장치를 신속하게 업데이트할 수 있습니다. 계획된 장애 조치(failover)는 일반적으로 1초 이내에 완료됩니다.

*계획되지 않은 장애 조치(failover)* 는 하드웨어 오류, 네트워크 오류 또는 주 노드에 대한 기타 예기치 않은 중단으로 인해 발생할 수 있습니다. 복제본 노드는 자체적으로 주 노드로 승격되지만 프로세스는 더 오래 걸립니다. 장애 조치(failover) 프로세스를 시작하려면 먼저 복제본 노드가 주 노드를 사용할 수 없음을 감지해야 합니다. 또한 복제본 노드는 불필요한 장애 조치(failover)를 방지하기 위해 이 계획되지 않은 오류가 일시적이거나 로컬이 아님을 확인해야 합니다. 이러한 검색 지연은 계획되지 않은 장애 조치(failover)가 일반적으로 10~15초 이내에 완료됨을 의미합니다.

## <a name="how-does-patching-occur"></a>패치는 어떻게 발생하나요?

Azure Cache for Redis 서비스는 정기적으로 최신 플랫폼 기능 및 수정 사항으로 캐시를 업데이트합니다. 캐시를 패치하기 위해 서비스는 다음 단계를 수행합니다.

1. 관리 서비스는 패치할 노드를 하나 선택합니다.
1. 선택한 노드가 주 노드인 경우 해당 복제본 노드는 협조적으로 승격됩니다. 이 승격은 계획된 장애 조치(failover)로 간주됩니다.
1. 선택한 노드가 다시 부팅되어 새 변경 내용을 적용하고 복제본 노드로 백업됩니다.
1. 복제본 노드는 주 노드에 연결되고 데이터를 동기화합니다.
1. 데이터 동기화가 완료되면 나머지 노드에 대해 패치 프로세스가 반복됩니다.

패치는 계획된 장애 조치(failover)이므로 복제본 노드는 신속하게 주 노드가 되도록 자체적으로 승격합니다. 그런 다음, 노드는 요청 및 새 연결 서비스를 시작합니다. 기본 캐시에는 복제본 노드가 없으며 업데이트가 완료될 때까지 사용할 수 없습니다. 클러스터형 캐시의 각 분할된 데이터베이스는 별도로 패치되며 다른 분할된 데이터베이스에 대한 연결을 닫지 않습니다.

> [!IMPORTANT]
> 노드는 데이터 손실을 방지하기 위해 한 번에 하나씩 패치됩니다. 기본 캐시는 데이터가 손실됩니다. 클러스터형 캐시는 한 번에 하나의 분할된 데이터베이스로 패치됩니다.

동일한 리소스 그룹 및 지역의 여러 캐시도 한 번에 하나씩 패치됩니다.  다른 리소스 그룹 또는 다른 지역에 있는 캐시는 동시에 패치될 수 있습니다.

프로세스가 반복되기 전에 전체 데이터 동기화가 발생하기 때문에 표준 또는 프리미엄 캐시를 사용할 때 데이터 손실이 발생할 가능성이 낮습니다. 데이터를 [내보내고](cache-how-to-import-export-data.md#export) [지속성](cache-how-to-premium-persistence.md)을 사용하도록 설정하여 데이터 손실을 추가로 방지할 수 있습니다.

## <a name="additional-cache-load"></a>추가 캐시 로드

장애 조치(failover)가 발생할 때마다 표준 및 프리미엄 캐시는 한 노드에서 다른 노드로 데이터를 복제해야 합니다. 이 복제로 인해 서버 메모리와 CPU의 부하가 어느 정도 증가합니다. 캐시 인스턴스가 이미 많이 로드된 경우 클라이언트 애플리케이션의 대기 시간이 증가할 수 있습니다. 극단적인 경우 클라이언트 애플리케이션은 시간 제한 예외를 수신할 수 있습니다. 더 많은 부하의 영향을 완화하려면 캐시의 `maxmemory-reserved` 설정을 [구성](cache-configure.md#memory-policies)합니다.

## <a name="how-does-a-failover-affect-my-client-application"></a>장애 조치(failover)는 클라이언트 애플리케이션에 어떤 영향을 미치나요?

클라이언트 애플리케이션에서 볼 수 있는 오류 수는 장애 조치(failover) 시 해당 연결에서 보류 중인 작업 수에 따라 달라집니다. 해당 연결을 닫은 노드를 통해 라우팅되는 모든 연결에 오류가 표시됩니다. 많은 클라이언트 라이브러리는 시간 제한 예외, 연결 예외 또는 소켓 예외를 포함하여 연결이 끊어질 때 다양한 유형의 오류를 throw할 수 있습니다. 예외의 수와 유형은 코드 경로에서 캐시가 연결을 닫을 때 요청이 있는 위치에 따라 달라집니다. 예를 들어, 요청을 보냈지만 장애 조치(failover)가 발생할 때 응답을 받지 못한 작업에서 시간 제한 예외가 발생할 수 있습니다. 닫힌 연결 개체에 대한 새 요청은 다시 연결이 성공적으로 발생할 때까지 연결 예외를 수신합니다.

대부분의 클라이언트 라이브러리는 캐시에 다시 연결하도록 구성된 경우 재연결을 시도합니다. 그러나 예기치 않은 버그로 인해 라이브러리 개체를 복구할 수 없는 상태가 될 수 있습니다. 미리 구성된 시간보다 오래 오류가 지속되면 연결 개체를 다시 만들어야 합니다. Microsoft.NET 및 기타 개체 지향 언어에서 애플리케이션을 다시 시작([Lazy\<T\> 패턴](https://gist.github.com/JonCole/925630df72be1351b21440625ff2671f#reconnecting-with-lazyt-pattern)을 사용하여 수행할 수 있음)하지 않고 연결을 다시 만들 수 있습니다.

### <a name="how-do-i-make-my-application-resilient"></a>복원력 있는 애플리케이션을 만들려면 어떻게 해야 하나요?

장애 조치(failover)를 완전히 방지할 수는 없으므로 연결 중단 및 실패한 요청에 대한 복원력을 갖추도록 클라이언트 애플리케이션을 작성합니다. 대부분의 클라이언트 라이브러리가 캐시 엔드포인트에 자동으로 다시 연결되지만 실패한 요청을 다시 시도하려는 경우는 거의 없습니다. 애플리케이션 시나리오에 따라 백오프와 함께 재시도 논리를 사용하는 것이 좋을 수 있습니다.

클라이언트 애플리케이션의 복원력을 테스트하려면 연결 중단을 수동 트리거로 [다시 부팅](cache-administration.md#reboot)을 사용합니다. 또한 캐시에서 [업데이트를 예약](cache-administration.md#schedule-updates)하는 것이 좋습니다. 지정된 주간 기간 동안 Redis 런타임 패치를 적용하도록 관리 서비스에 지시합니다. 이러한 기간은 일반적으로 잠재적인 인시던트 방지를 위해 클라이언트 애플리케이션 트래픽이 낮은 기간입니다.

### <a name="can-i-be-notified-in-advance-of-a-planned-maintenance"></a>계획된 유지 관리 전에 알림을 받을 수 있나요?

이제 Azure Cache for Redis가 계획된 업데이트 약 30초 전에 [AzureRedisEvents](https://github.com/Azure/AzureCacheForRedis/blob/main/AzureRedisEvents.md)라는 게시/구독 채널에 알림을 게시합니다. 알림은 런타임 알림입니다. 특히 회로 차단기를 사용하여 캐시 또는 버퍼 명령을 바이패스할 수 있는 애플리케이션(예: 계획된 업데이트 중)용으로 제작되었습니다. 며칠 또는 몇 시간 전에 알릴 수 있는 메커니즘이 아닙니다.

### <a name="client-network-configuration-changes"></a>클라이언트 네트워크 구성 변경 사항

특정 클라이언트 쪽 네트워크 구성 변경은 “연결을 사용할 수 없음” 오류를 트리거할 수 있습니다. 이러한 변경 내용에는 다음이 포함됩니다.

- 스테이징 슬롯과 프로덕션 슬롯 간에 클라이언트 애플리케이션의 가상 IP 주소 교환.
- 애플리케이션의 인스턴스 크기 또는 수 조정.

이러한 변경으로 인해 1분 미만으로 지속되는 연결 문제가 발생할 수 있습니다. 클라이언트 애플리케이션은 다른 외부 네트워크 리소스뿐만 아니라 Azure Cache for Redis 서비스에 대한 연결이 끊어질 수 있습니다.

## <a name="next-steps"></a>다음 단계

- 캐시에 대한 [업데이트를 예약](cache-administration.md#schedule-updates)합니다.
- [다시 부팅](cache-administration.md#reboot)을 사용하여 애플리케이션 복원력을 테스트합니다.
- 메모리 예약 및 정책을 [구성](cache-configure.md#memory-policies)합니다.
