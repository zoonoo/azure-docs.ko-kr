<properties
   pageTitle="API 디자인 지침 | Microsoft Azure"
   description="잘 디자인된 API를 만드는 방법에 관한 지침입니다."
   services=""
   documentationCenter="na"
   authors="dragon119"
   manager="masimms"
   editor=""
   tags=""/>

<tags
   ms.service="best-practice"
   ms.devlang="rest-api"
   ms.topic="article"
   ms.tgt_pltfrm="na"
   ms.workload="na"
   ms.date="04/28/2015"
   ms.author="masashin"/>

# API 디자인 지침

![](media/best-practices-api-design/pnp-logo.png)

이 지침에 포함된 일부 항목은 논의 중이며 나중에 변경될 수 있습니다. 귀하의 피드백을 환영합니다!


## 개요

많은 최신 웹 기반 솔루션은 웹 서버에서 호스트되는 웹 서비스를 사용하여 원격 클라이언트 응용 프로그램의 기능을 제공합니다. 웹 API는 웹 서비스에 표시되는 작업으로 구성됩니다. 잘 디자인된 웹 API는 아래와 같은 특성을 지원해야 합니다.

- **플랫폼 독립성**. 클라이언트 응용 프로그램은 API에 표시되는 데이터 또는 작업이 물리적으로 구현된 방법과 상관없이 웹 서비스가 제공하는 API를 이용할 수 있어야 합니다. 즉, API는 클라이언트 응용 프로그램과 웹 서비스가 사용할 데이터 형식 및 클라이언트 응용 프로그램과 웹 서비스 간에 교환되는 데이터의 구조를 일치시킬 수 있는 공통 표준을 적용해야 합니다.

- **서비스 진화**. 웹 서비스는 클라이언트 응용 프로그램과 독립적으로 기능을 진화시키고 추가(또는 제거)할 수 있어야 합니다. 기존 클라이언트 응용 프로그램은 웹 서비스가 제공하는 기능이 변화하더라도 수정되지 않고 계속 작동할 수 있어야 합니다. 또한 모든 기능은 클라이언트 응용 프로그램이 해당 기능을 완전히 이용할 수 있도록 검색이 가능해야 합니다.

이 지침에서는 웹 API를 디자인할 때 고려해야 하는 문제를 설명합니다.

## REST(Representational State Transfer) 소개

Roy Fielding은 2000년에 자신의 논문에서 웹 서비스에서 표시되는 작업의 구조를 지정하는 대체 아키텍처 접근 방식인 REST를 제안했습니다. REST는 하이퍼미디어 기반 분산 시스템을 구축하기 위한 아키텍처 스타일입니다. REST 모델의 주요 이점은 개방형 표준을 기반으로 하고 있어 해당 모델에 액세스하는 모델 또는 클라이언트 응용 프로그램의 구현이 특정 구현에 바인딩되지 않는다는 것입니다. 예를 들어 Microsoft ASP.NET Web API를 사용하여 REST 웹 서비스를 구현하거나 HTTP 요청을 생성하고 HTTP 응답을 구문 분석할 수 있는 어떤 언어와 도구 집합에 의해서도 클라이언트 응용 프로그램을 개발할 수 있습니다.

> [AZURE.NOTE]\:실제로 REST는 어떤 기본 프로토콜과도 독립적이며 HTTP에 연결될 필요가 없습니다. 그러나 REST를 기반으로 하는 시스템의 가장 일반적인 구현은 요청을 보내고 받기 위한 응용 프로그램 프로토콜로 HTTP를 이용합니다. 이 문서에서는 HTTP를 사용하여 작동하도록 디자인된 시스템에 REST 원리를 매핑하는 데 집중합니다.

REST 모델은 탐색 체계를 사용하여 네트워크를 통해 개체 및 서비스(_리소스_라고 함)를 나타냅니다. 일반적으로 REST를 구현하는 많은 시스템은 HTTP 프로토콜을 사용하여 이러한 리소스에 액세스하기 위한 요청을 전송합니다. 이러한 시스템에서 클라이언트 응용 프로그램은 리소스를 식별하는 URI 및 해당 리소스에 대해 수행할 작업을 나타내는 HTTP 메서드(GET, POST, PUT 또는 DELETE가 가장 일반적임) 형식으로 요청을 제출합니다. HTTP 요청의 본문은 작업을 수행하는 데 필요한 데이터를 포함하고 있습니다. 특히 REST는 상태 비저장 요청 모델을 정의합니다. HTTP 요청은 독립적이어야 하고 임의 순서로 발생할 수 있으므로, 요청 사이의 일시적인 상태 정보를 유지하려고 시도하는 것은 타당하지 않습니다. 정보는 리소스 자체에만 저장되며 각 요청은 자동 작업이어야 합니다. 결국 REST 모델은 요청이 리소스를 잘 정의되고 일시적이지 않은 상태를 다른 상태로 전환하는 유한 상태 시스템을 구현합니다.

> [AZURE.NOTE]REST 모델의 개별 요청은 상태를 저장하지 않는 특성이 있으므로 이 원리에 따라 생성된 시스템은 확장성이 매우 높습니다. 따라서 일련의 요청을 하는 클라이언트 응용 프로그램과 해당 요청을 처리하는 특정 웹 서버 사이에 선호도를 유지할 필요가 없습니다.

또한 효과적인 REST 모델을 구현하려면 모델이 액세스를 제공하는 여러 리소스 사이의 관계를 잘 알아야 합니다. 이러한 리소스는 일반적으로 컬렉션과 관계로 구성됩니다. 예를 들어 전자 상거래 시스템을 빨리 분석해 보니 클라이언트 응용 프로그램에서 관심을 가질 수 있는 주문(orders)과 고객(customers)이라는 두 컬렉션이 있다고 가정하겠습니다. 식별을 위해 각 주문과 고객에 자체의 고유한 키를 지정해야 합니다. 주문 컬렉션에 액세스하기 위한 URI는 단순히 _/orders_이며, 마찬가지로 모든 고객을 검색하기 위한 URI는 _/customers_일 것입니다. _/orders_ URI에 대해 HTTP GET 요청을 실행하면 HTTP 응답으로 인코딩된 컬렉션의 모든 주문을 나타내는 목록이 반환될 것입니다.

```HTTP
GET http://adventure-works.com/orders HTTP/1.1
...
```

아래와 같은 응답은 주문을 XML 목록 구조로 인코딩합니다. 목록에는 주문 7개가 포함되어 있습니다.

```HTTP
HTTP/1.1 200 OK
...
Date: Fri, 22 Aug 2014 08:49:02 GMT
Content-Length: ...
<OrderList xmlns:i="..." xmlns="..."><Order><OrderID>1</OrderID><OrderValue>99.90</OrderValue><ProductID>1</ProductID><Quantity>1</Quantity></Order><Order><OrderID>2</OrderID><OrderValue>10.00</OrderValue><ProductID>4</ProductID><Quantity>2</Quantity></Order><Order><OrderID>3</OrderID><OrderValue>16.60</OrderValue><ProductID>2</ProductID><Quantity>4</Quantity></Order><Order><OrderID>4</OrderID><OrderValue>25.90</OrderValue><ProductID>3</ProductID><Quantity>1</Quantity></Order><Order><OrderID>7</OrderID><OrderValue>99.90</OrderValue><ProductID>1</ProductID><Quantity>1</Quantity></Order></OrderList>
```
개별 주문을 가져오려면 _orders_ 리소스에서 _/orders/2_ 같은 순서 식별자를 지정해야 합니다.

```HTTP
GET http://adventure-works.com/orders/2 HTTP/1.1
...
```

```HTTP
HTTP/1.1 200 OK
...
Date: Fri, 22 Aug 2014 08:49:02 GMT
Content-Length: ...
<Order xmlns:i="..." xmlns="...">
<OrderID>2</OrderID><OrderValue>10.00</OrderValue><ProductID>4</ProductID><Quantity>2</Quantity></Order>
```

> [AZURE.NOTE]간단히 하기 위해 이 예에서는 반환되는 응답에서 정보를 XML 텍스트 데이터로 표시합니다. 그러나 리소스가 HTTP에서 지원되는 다른 데이터 형식(이진 또는 암호화된 형식 등)을 포함해도 상관없으며, HTTP 응답의 콘텐츠 형식에 해당 형식을 지정해야 합니다. 또한 REST 모델은 같은 데이터를 XML 또는 JSON 등의 다른 형식으로 반환할 수도 있습니다. 이 경우 웹 서비스는 요청을 하는 클라이언트와 콘텐츠 협상을 수행할 수 있어야 합니다. 요청은 클라이언트가 수신하고자 하는 기본 설정 형식을 지정하는 _Accept_ 헤더를 포함할 수 있으며 웹 서비스는 가능하면 이 형식을 적용하려고 해야 합니다.

참고로 REST 요청에 대한 응답은 표준 HTTP 상태 코드를 사용합니다. 예를 들어 유효한 데이터를 반환하는 요청은 HTTP 응답 코드 200(정상)을 포함해야 하는 반면, 지정된 리소스를 찾거나 삭제하는 데 실패한 요청은 HTTP 상태 코드 404(찾을 수 없음)가 포함된 응답을 반환해야 합니다.

## RESTful 웹 API의 디자인 및 구조

성공적인 웹 API를 디자인하는 핵심 요소는 단순성과 일관성입니다. 이러한 두 요소를 보여 주는 웹 API를 이용하면 API를 사용해야 하는 클라이언트 응용 프로그램을 만들기 쉽습니다.

RESTful 웹 API는 일련의 연결된 리소스 표시 및 응용 프로그램이 이러한 리소스를 조작하고 리소스 사이를 쉽게 탐색할 수 있는 코어 작업을 제공하는 데 집중합니다. 따라서 일반적인 RESTful 웹 API를 구성하는 URI는 표시하는 데이터를 지향해야 하며 HTTP가 이 데이터에 대해 작업하기 위해 제공하는 기능을 사용해야 합니다. 이 접근 방식을 채택하려면 개체와 클래스의 동작의 영향을 더 많이 받는 경향이 있는 개체 지향 API에 클래스 집합을 디자인할 때 일반적으로 채택되는 것과는 다른 사고방식을 가져야 합니다. 또한 RESTful 웹 API는 상태 비저장이어야 하며 특정 순서로 호출되는 작업에 종속되지 않아야 합니다. 다음 섹션에서는 RESTful 웹 API를 디자인할 때 고려해야 할 요소를 요약 합니다.

### 웹 API 기반 리소스 구성

> [AZURE.TIP]REST 웹 서비스가 표시하는 URI는 동사(응용 프로그램이 데이터에 대해 수행할 수 있는 동작)가 아닌 명사(웹 API가 액세스를 제공하는 데이터)를 기반으로 해야 합니다.

즉, 웹 API가 표시하는 비즈니스 엔터티에 집중해야 합니다. 예를 들어 앞에서 설명한 전자 상거래 시스템을 지원하도록 디자인된 웹 API의 경우, 기본 엔터티는 고객과 주문입니다. 주문을 수행하는 동작과 같은 프로세스는 주문 정보를 가져와서 고객의 주문 목록에 추가하는 HTTP POST 작업을 제공하면 구현할 수 있습니다. 내부적으로 볼 때 이 POST 작업은 재고 수준 확인 및 고객에 대한 청구 등의 작업을 수행할 수 있습니다. HTTP 응답은 주문이 성공적으로 수행되었는지 여부를 나타낼 수 있습니다. 또한 리소스는 단일 물리적 데이터 항목을 기반으로 할 필요가 없습니다. 한 예로, 관계형 데이터베이스의 여러 테이블에 분포된 많은 행에서 집계되지만 클라이언트에 대해서는 단일 엔터티로 표시되는 정보를 사용하여 내부적으로 주문 리소스를 구현할 수 있습니다.

> [AZURE.TIP]표시하는 데이터의 내부 구조를 미러링하거나 해당 구조에 따라 좌우되는 REST 인터페이스를 디자인하지 않는 것이 좋습니다. REST는 관계형 데이터베이스에서 별도 테이블에 대해 간단한 CRUD(만들기, 검색, 업데이트, 삭제) 작업을 구현하는 것 이상의 많은 기능을 가지고 있습니다. REST의 목적은 비즈니스 엔터티와 응용 프로그램이 해당 엔터티에 대해 수행할 수 있는 작업을 매핑하는 것이지만, 이러한 물리적 세부사항을 클라이언트에 표시하지 않아야 합니다.

개별 비즈니스 엔터티가 분리되어 존재하는 경우는 거의 없으며(일부 단일 항목 개체는 존재할 수 있지만) 컬렉션으로 함께 그룹화되는 경향이 있습니다. REST과 관련해서는 각 엔터티와 각 컬렉션을 리소스라고 합니다. RESTful 웹 API에서 각 컬렉션은 웹 서비스 내에서 자체의 URI를 가지고 있으며 컬렉션의 URI에 대해 HTTP GET 요청을 수행하면 해당 컬렉션에서 항목 목록이 검색됩니다. 또한 각 개별 항목도 자체 URI를 가지고 있으며, 응용 프로그램은 이 URI를 사용하여 HTTP GET 요청을 제출하여 해당 항목의 세부 정보를 검색할 수 있습니다. 컬렉션과 항목에 대해 계층적인 방법으로 URI를 구성해야 합니다. 전자 상거래 시스템에서 URI _/customers_는 고객의 컬렉션을 나타내며, _/customers/5_는 이 컬렉션에서 ID가 5인 단일 고객에 대한 세부 정보를 검색합니다. 이 접근 방식을 사용하면 웹 API를 직관적으로 유지할 수 있습니다.

> [AZURE.TIP]URI에 일관성 있는 명명 규칙을 적용해야 하며, 일반적으로 이렇게 하면 컬렉션을 참조하는 URI에 대해 복수 명사를 사용할 수 있습니다.

또한 서로 다른 리소스 형식과 이러한 연결을 표시하는 방법 사이의 관계도 고려해야 합니다. 예를 들어 고객은 0개 이상의 주문을 할 수 있습니다. _/customers/5/orders_ 같은 URI를 통해 고객 5에 대한 모든 주문을 찾는 것은 이 관계를 나타내는 자연스러운 방법이 될 수 있습니다. 또한 _/orders/99/customer_ 같은 URI를 통해 주문에서 특정 고객에게 다시 돌아가는 연결을 나타냄으로써 주문 99에 대한 고객을 찾을 수도 있지만, 이 모델을 너무 크게 확장하면 구현하기가 번거로워질 수 있습니다. 더 나은 방법은 주문을 쿼리할 때 반환되는 HTTP 응답 메시지의 본문에 고객 같은 연결된 리소스에 대한 탐색 가능한 링크를 제공하는 것입니다. 이 메커니즘은 이 지침의 후반부에 나오는 HATEOAS 접근 방식을 사용하여 관련 리소스 탐색 사용에 더 자세히 설명되어 있습니다.

더 복잡한 시스템에는 더 많은 엔터티 형식이 있을 수 있으며, 클라이언트 응용 프로그램이 _/customers/1/orders/99/products_와 같이 여러 수준의 관계를 통해 탐색하여 고객 1이 실행한 주문 99의 제품 목록을 가져올 수 있는 URI를 제공할 수 있습니다. 그러나 이 수준의 복잡성은 유지하기 어려울 수 있으며 나중에 리소스 사이의 관계가 변하면 유연성이 떨어집니다. 가능하면 URI를 비교적 단순하게 유지하도록 노력해야 합니다. 응용 프로그램이 리소스 참조를 지정한 후에는 이 참조를 사용하여 해당 리소스와 관련된 항목을 찾을 수 있어야 한다는 점에 주의해야 합니다. 앞의 쿼리를 _/customers/1/orders_로 바꾸어 고객 1에 대한 모든 주문을 찾은 다음 URI _/orders/99/products_를 쿼리하여 이 주문의 제품을 찾을 수 있습니다(주문 99를 고객 1이 했다고 가정).

> [AZURE.TIP]리소스 URI를 _컬렉션/항목/컬렉션_보다 더 복잡하게 요구하지 않는 것이 좋습니다.

또한 모든 웹 요청은 웹 서버에 부담을 주며 요청 수가 많을수록 이 부담이 더 커진다는 점도 고려해야 합니다. 다수의 작은 리소스를 표시하는 "번잡한" 웹 API를 피하도록 리소스를 정의하기 위해 노력해야 합니다. 그러한 API를 사용하려면 클라이언트 응용 프로그램이 요구하는 모든 데이터를 찾기 위해 복수의 요청을 제출해야 할 수 있습니다. 데이터를 비정규화하고 관련 정보를 단일 요청에 의해 검색할 수 있는 더 큰 리소스로 함께 결합하는 것이 좋습니다. 단, 이 접근 방식과 클라이언트가 자주 요구하지 않는 데이터를 가져오는 오버헤드의 균형을 조정해야 합니다. 큰 개체를 검색하면 요청의 대기 시간이 증가하고 추가 데이터를 자주 사용하지 않는 경우 작은 이익을 얻기 위해 추가 대역폭 비용을 초래할 수 있습니다.

웹 API와 기본 데이터 원본의 구조, 형식 또는 위치 사이에 종속성이 발생하지 않도록 해야 합니다. 예를 들어 데이터가 관계형 데이터베이스에 있는 경우, 웹 API는 각 테이블을 리소스 컬렉션으로 표시할 필요가 없습니다. 웹 API를 데이터베이스의 추상화하고 생각하고 필요한 경우 데이터베이스와 웹 API 사이에 매핑 계층을 적용합니다. 이러한 방식으로 데이터베이스의 디자인 또는 구현이 변경된 경우(예를 들어 정규화된 테이블의 컬렉션이 포함된 관계형 데이터베이스에서 문서 데이터베이스 같은 비정규화 NoSQL 저장소 시스템으로 이동한 경우) 클라이언트 응용 프로그램은 이러한 변경 내용을 인식하지 못하게 됩니다.
> [AZURE.TIP]웹 API를 바탕으로 하는 데이터의 원본은 데이터 저장소일 필요가 없으며, 다른 서비스 또는 기간 업무 응용 프로그램 또는 조직 내에서 온-프레미스로 실행되는 레거시 응용 프로그램일 수도 있습니다.

마지막으로, 웹 API에 의해 구현된 일부 작업을 특정 리소스에 매핑하지 못할 수 있습니다. HTTP GET 요청을 통해 기능의 일부를 호출하고 결과를 HTTP 응답 메시지로 반환하는 _리소스가 아닌_ 시나리오를 처리할 수 있습니다. 더하기 및 빼기 같은 단순한 계산기 스타일의 작업을 구현하는 웹 API는 이러한 작업을 의사 리소스로 표시하고 쿼리 문자열을 사용하여 필요한 매개 변수를 지정하는 URI를 제공할 수 있습니다. 예를 들어 URI _/add?operand1=99&operand2=1_에 대한 GET 요청은 본문에 값 100이 포함된 응답 메시지를 반환할 수 있으며, URI _/subtract?operand1=50&operand2=20_에 대한 GET 요청은 본문에 값 30이 포함된 응답 메시지를 반환할 수 있습니다. 그러나 이러한 형식의 URI는 제한적으로만 사용해야 합니다.

### HTTP 메서드를 기준으로 작업 정의

HTTP 프로토콜은 요청에 의미 체계의미를 할당하는 다양한 메서드를 정의합니다. 대부분의 RESTful 웹 API에서 사용하는 일반적인 HTTP 메서드는 다음과 같습니다.

- **GET**, 지정된 URI에서 리소스의 복사본을 검색합니다. 응답 메시지의 본문은 요청된 리소스의 세부 정보를 포함하고 있습니다.

- **POST**, 지정된 URI에 새 리소스를 만듭니다. 요청 메시지의 본문은 새 리소스의 세부 정보를 제공합니다. 참고로 POST를 사용하여 실제로 리소스를 만들지 않는 작업을 트리거할 수도 있습니다.

- **PUT**, 지정된 URI의 리소스를 바꾸거나 업데이트합니다. 요청 메시지의 본문은 수정할 리소스 및 적용할 값을 지정합니다.

- **DELETE**, 지정된 URI의 리소스를 제거합니다.

> [AZURE.NOTE]또한 HTTP 프로토콜은 리소스에 대한 선택적 업데이트를 요청하는 데 사용하는 PATCH, 리소스 설명을 요청하는 데 사용하는 HEAD, 클라이언트가 서버에서 지원되는 통신 옵션에 관한 정보를 가져올 수 있는 OPTIONS 및 클라이언트가 테스트와 진단 목적으로 사용할 수 있는 정보를 가져올 수 있는 TRACE 등 일반적으로 사용되지 않는 다른 메서드도 정의합니다.

특정 요청의 효과는 적용되는 리소스가 컬렉션인지 아니면 개별 항목인지에 따라 달라져야 합니다. 다음 표는 전자 상거래 예제를 사용 하여 대부분의 RESTful 구현에서 적용하는 일반적인 규칙을 요약합니다. 참고로 이 요청 중 일부는 구현되지 않을 수 있으며, 구현 여부는 특정 시나리오에 따라 다릅니다.

| **리소스** | **POST** | **GET** | **PUT** | **DELETE** |
|--------------|----------|---------|---------|------------|
| /customers | 새 고객 만들기 | 모든 고객 검색 | 고객에 대한 일괄 업데이트(_구현된 경우_) | 모든 고객 제거 |
| /customers/1 | 오류 | 고객 1에 대한 세부 정보 검색 | 존재하는 경우 고객 1의 세부 정보 업데이트, 그렇지 않으면 오류 반환 | 고객 1 제거 |
| /customers/1/orders | 고객 1에 대한 새 주문 만들기 | 고객 1에 대한 모든 주문 검색 | 고객 1에 대한 주문 일괄 업데이트(_구현된 경우_) | 고객 1에 대한 주문 제거(_구현된 경우_) |

GET 및 DELETE 요청의 목적은 비교적 간단하지만, POST 및 PUT 요청의 목적과 효과에 대해서는 혼동을 일으키는 범위가 있습니다.

POST 요청은 요청 본문에 제공된 데이터를 사용하여 새 리소스를 만듭니다. REST 모델에서는 흔히 POST 요청을 컬렉션인 리소스에 적용하며, 새 리소스는 컬렉션에 추가됩니다.

> [AZURE.NOTE]일부 기능을 트리거하는(그리고 데이터를 반환하지 않을 수도 있는) POST 요청을 정의할 수도 있으며, 이러한 요청 형식을 컬렉션에 적용할 수 있습니다. 예를 들어 POST 요청을 사용하여 급여 처리 서비스에 작업표를 전달하고 계산된 세금을 다시 응답으로 가져옵니다.

PUT 요청은 기존 리소스를 수정하기 위한 것입니다. 지정된 리소스가 존재하지 않는 경우, PUT 요청은 오류를 반환할 수 있습니다(경우에 따라 실제로 리소스를 만들 수 있음). PUT 요청은 컬렉션에 적용될 수 있지만(일반적으로 이렇게 구현하지 않지만) 개별 항목인 리소스(특정 고객 또는 주문)에 적용되는 경우가 가장 많습니다. 참고로 PUT 요청은 멱등원이지만 POST 요청은 그렇지 않습니다. 즉, 응용 프로그램이 같은 PUT 요청을 여러 번 제출하더라도 결과는 항상 같지만(같은 리소스가 같은 값으로 수정됨), 응용 프로그램이 같은 POST 요청을 반복하면 결과는 복수의 리소스가 생성됩니다.

> [AZURE.NOTE]엄격히 말해서, HTTP PUT 요청은 기존 리소스를 요청 본문에 지정된 리소스로 바꿉니다. 리소스의 속성 선택을 수정하지만 다른 속성을 변경하지 않으려는 경우, HTTP PATCH 요청을 사용하여 이 기능을 구현해야 합니다. 그러나 많은 RESTful 구현은 이 규칙을 완화하며 두 상황에 모두 PUT을 사용합니다.

### HTTP 요청 처리
많은 HTTP 요청에서 클라이언트 응용 프로그램이 포함시킨 데이터 및 웹 서버에서 오는 해당 응답 메시지를 다양한 형식(또는 미디어 형식)으로 제공할 수 있습니다. 예를 들어, 고객 또는 주문에 대한 세부 정보를 지정하는 데이터를 XML, JSON 또는 다른 인코딩 및 압축된 형식으로 제공할 수 있습니다. RESTful 웹 API는 요청을 제출하는 클라이언트 응용 프로그램에서 요청한 대로 서로 다양한 미디어 형식을 지원해야 합니다.

클라이언트 응용 프로그램은 메시지 본문에 데이터를 반환하는 요청을 보낼 때 처리할 수 있는 미디어 형식을 요청의 Accept 헤더에 지정할 수 있습니다. 다음 코드에서는 고객 1에 대한 세부 정보를 검색하고 반환할 결과를 JSON으로 요청하는 HTTP GET을 보여 줍니다. 클라이언트는 반환되는 데이터의 형식을 확인하기 위해 여전히 응답의 데이터의 미디어 형식을 검사해야 합니다.

```HTTP
GET http://adventure-works.com/orders/2 HTTP/1.1
...
Accept: application/json
...
```

웹 서버는 이 미디어 형식을 지원하는 경우 메시지 본문의 데이터 형식을 지정하는 Content-Type 헤더를 포함하고 있는 응답으로 회신할 수 있습니다.

> [AZURE.NOTE]상호 운용성을 최대로 높이기 위해, Accept 및 Content-Type 헤더에 참조되는 미디어 형식은 일부 사용자 지정 미디어 형식이 아닌 MIME 형식으로 인식됩니다.

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/json; charset=utf-8
...
Date: Fri, 22 Aug 2014 09:18:37 GMT
Content-Length: ...
{"OrderID":2,"ProductID":4,"Quantity":2,"OrderValue":10.00}
```

요청된 미디어 형식을 지원하지 않는 경우, 웹 서버는 데이터를 다른 형식으로 보낼 수 있습니다. 모든 경우 Content-type 헤더에 미디어 형식을 지정해야 합니다(예: _text/xml_). 응답 메시지를 분석하고 메시지 본문의 결과를 적절히 해석하는 것은 클라이언트 응용 프로그램에서 해야 합니다.

참고로 이 예에서 웹 서버는 성공적으로 요청 데이터를 검색하며 응답 헤더에 상태 코드 200을 전달하여 성공을 나타냅니다. 일치하는 데이터가 없으면 상태 코드 404(찾을 수 없음)을 대신 반환해야 하며 응답 메시지의 본문에 추가 정보가 포함될 수 있습니다. 이 정보의 형식은 다음 예제와 같이Content-type 헤더에 의해 지정됩니다.

```HTTP
GET http://adventure-works.com/orders/222 HTTP/1.1
...
Accept: application/json
...
```

주문 222는 존재하지 않으므로 응답 메시지는 다음과 같습니다.

```HTTP
HTTP/1.1 404 Not Found
...
Content-Type: application/json; charset=utf-8
...
Date: Fri, 22 Aug 2014 09:18:37 GMT
Content-Length: ...
{"Message":"No such order"}
```

응용 프로그램은 리소스를 업데이트하는 HTTP PUT 요청을 보낼 때 리소스의 URI를 지정하고 수정할 데이터를 요청 메시지의 본문에 제공합니다. 또한 Content-Type 헤더를 사용하여 이 데이터의 형식을 지정해야 합니다. 텍스트 기반 정보에 사용되는 일반적인 형식은 _application/x-www-form-urlencoded_이며, 이 형식은 & 문자로 구분되는 이름/값 쌍의 집합으로 구성됩니다. 다음 예제에서는 주문 1의 정보를 수정하는 HTTP PUT 요청을 보여 줍니다.

```HTTP
PUT http://adventure-works.com/orders/1 HTTP/1.1
...
Content-Type: application/x-www-form-urlencoded
...
Date: Fri, 22 Aug 2014 09:18:37 GMT
Content-Length: ...
ProductID=3&Quantity=5&OrderValue=250
```

수정에 성공할 경우, 프로세스가 성공적으로 처리되었지만 응답 본문에 추가 정보가 포함되지 않았음을 나타내는 HTTP 204 상태 코드로 응답하는 것이 최적입니다. 응답의 Location 헤더에는 새로 업데이트된 리소스의 URI가 포함되어 있습니다.

```HTTP
HTTP/1.1 204 No Content
...
Location: http://adventure-works.com/orders/1
...
Date: Fri, 22 Aug 2014 09:18:37 GMT
```

> [AZURE.TIP]HTTP PUT 요청 메시지의 데이터가 날짜 및 시간 정보를 포함한 경우, 사용자의 웹 서비스는 ISO 8601 표준을 따르는 형식의 날짜 및 시간을 수락하는지 확인합니다.

업데이트할 리소스가 없는 경우, 웹 서버는 앞에서 설명한 대로 찾을 수 없음 응답으로 응답할 수 있습니다. 또는 서버가 개체 자체를 실제로 만드는 경우, 상태 코드 HTTP 200(정상) 또는 HTTP 201(생성됨)를 반환하며 응답 본문은 새 리소스에 대한 데이터를 포함할 수 있습니다. 요청의 Content-Type 헤더가 웹 서버에서 처리할 수 없는 데이터 형식을 지정한 경우, HTTP 상태 코드 415(지원되지 않는 미디어 형식)으로 응답해야 합니다.

> [AZURE.TIP]컬렉션의 복수 리소스에 대한 업데이트를 일괄 처리할 수 있는 일괄 HTTP PUT 작업의 구현을 생각해 보겠습니다. PUT 요청은 컬렉션의 URI를 지정해야 하며, 요청 본문에 수정할 리소스의 세부 정보를 지정해야 합니다. 이 접근 방식은 데이터 전송량을 줄이고 성능을 향상시킬 수 있습니다.

새 리소스를 만드는 HTTP POST 요청의 형식은 PUT 요청과 유사하며, 메시지 본문에 추가할 새 리소스의 세부 정보를 포함합니다. 그러나 URI는 일반적으로 리소스를 추가해야 할 컬렉션을 지정합니다. 다음 예제에서는 새 주문을 만들어 주문 컬렉션에 추가합니다.

```HTTP
POST http://adventure-works.com/orders HTTP/1.1
...
Content-Type: application/x-www-form-urlencoded
...
Date: Fri, 22 Aug 2014 09:18:37 GMT
Content-Length: ...
ProductID=5&Quantity=15&OrderValue=400
```

요청에 성공하면 HTTP 상태 코드 201(생성됨)이 포함된 메시지 코드로 응답해야 합니다. Location 헤더는 새로 만든 리소스의 URI를 포함해야 하며, 응답의 본문에 새 리소스의 복사본이 있어야 합니다. Content-type 헤더에는 이 데이터의 형식을 지정합니다.

```HTTP
HTTP/1.1 201 Created
...
Content-Type: application/json; charset=utf-8
Location: http://adventure-works.com/orders/99
...
Date: Fri, 22 Aug 2014 09:18:37 GMT
Content-Length: ...
{"OrderID":99,"ProductID":5,"Quantity":15,"OrderValue":400}
```

> [AZURE.TIP]PUT 또는 POST 요청에 의해 제공되는 데이터가 유효하지 않은 경우, 웹 서버는 HTTP 상태 코드 400(잘못된 요청)이 포함된 메시지로 응답해야 합니다. 이 메시지의 본문은 요청 및 예상되는 형식과 함께 문제에 대한 추가 정보를 포함하거나 더 자세한 정보를 제공하는 URL에 대한 링크를 포함할 수 있습니다.

리소스를 제거하려면 HTTP DELETE 요청 단순히 삭제할 리소스의 URI를 제공합니다. 다음 예제에서는 주문 99를 제거하려고 시도합니다.

```HTTP
DELETE http://adventure-works.com/orders/99 HTTP/1.1
...
```

삭제에 성공하면 웹 서버는 프로세스가 성공적으로 처리되었지만 응답 본문에 추가 정보가 없음을 나타내는 HTTP 상태 코드 204로 응답해야 합니다. 이는 성공한 PUT 작업에서 반환된 것과 같은 응답이지만, 리소스가 더 이상 존재하지 않으므로 Location 헤더가 없습니다. 또한 삭제가 비동기 방식으로 수행되는 경우 DELETE 요청이 HTTP 상태 코드 200(정상) 또는 202(수락)를 반환할 수 있습니다.

```HTTP
HTTP/1.1 204 No Content
...
Date: Fri, 22 Aug 2014 09:18:37 GMT
```

리소스가 없으면 웹 서버는 404(찾을 수 없음) 메시지를 대신 반환해야 합니다.

> [AZURE.TIP]컬렉션의 모든 리소스를 삭제해야 하는 경우, 응용 프로그램이 컬렉션에서 각 리소스를 차례로 삭제하게 하는 대신 컬렉션의 URI에 대해 HTTP DELETE 요청을 지정할 수 있습니다.

### 데이터 필터링 및 페이지 매김

URI를 단순하고 직관적으로 유지하려고 노력해야 합니다. 단일 URI를 통해 리소스 컬렉션을 표시하면 이렇게 하는 데 도움이 되지만, 응용 프로그램이 정보의 하위 집합만 필요한데도 대량의 데이터를 가져오게 될 수 있습니다. 대량의 트래픽이 발생하면 웹 서버의 성능 및 확장성에도 나쁜 영향을 미칠 뿐만 아니라 데이터를 요청하는 클라이언트 응용 프로그램의 응답성도 저하됩니다.

예를 들어 주문에 대해 지불한 가격이 주문에 포함된 경우, 비용이 특정 값 범위인 모든 주문을 검색해야 하는 클라이언트 응용 프로그램이 _/orders_ URI에서 모든 주문을 검색하고 이러한 주문을 로컬에서 필터링할 수 있습니다. 이 프로세스가 매우 비효율적인 것은 분명하며, 웹 API를 호스팅하는 서버의 네트워크 대역폭 및 처리 능력을 낭비합니다.

_/orders/ordervalue\_greater\_than\_n_(단 _n_은 주문 가격) 같은 URI 체계를 제공하는 것이 한 가지 해결 방법이지만, 제한된 수의 가격을 제외한 모든 가격의 경우 이러한 접근 방식이 사실상 불가능합니다. 또한 주문을 다른 기준에 따라 쿼리해야 하는 경우, 직관적이지 않을 수 있는 이름과 함께 URI의 긴 목록을 제공하게 될 수 있습니다.

더 나은 데이터 필터링 방법은 웹 API에 전달되는 쿼리 문자열에 _/orders? ordervaluethreshold = n_ 같은 필터 조건을 제공하는 것입니다. 이 예제에서는 웹 API의 해당 작업에서 쿼리 문자열의 `ordervaluethreshold` 매개 변수를 구문 분석 및 처리하고 필터링된 결과를 HTTP 응답에 반환합니다.

컬렉션 리소스에 대한 일부 간단한 HTTP GET 요청은 다수의 항목을 반환할 가능성이 있습니다. 이 문제 발생의 가능성에 대처하려면 웹 API를 단일 요청에서 반환되는 데이터의 양이 제한되도록 디자인해야 합니다. 사용자가 검색할 최대 항목 수(이 자체도 서비스 거부 공격을 방지하기 위해 상한값을 지정해야 할 수 있음)를 지정할 수 있는 쿼리 문자열과 컬렉션에 대한 시작 오프셋을 지원하면 이 목적을 달성할 수 있습니다. 예를 들어 URI _/orders?limit=25&offset=50_의 쿼리 문자열은 주문 컬렉션에서 발견된 50번째 주문부터 시작하여 주문 25개를 검색해야 합니다. 데이터 필터링과 마찬가지로 웹 API에서 GET 요청을 구현하는 작업도 쿼리 문자열의 `limit` 및 `offset` 매개 변수를 구문 분석 및 처리해야 합니다. 클라이언트 응용 프로그램을 돕기 위해, 페이지가 매겨진 데이터를 반환하는 GET 요청은 컬렉션의 사용할 수 있는 총 리소스 수를 나타내는 모종의 메타데이터 형식을 포함해야 합니다. 다른 지능적인 페이지 매김 방법을 생각할 수도 있으며, 자세한 내용은 [API 설계 참고 사항: 스마트 페이지 매김](http://bizcoder.com/api-design-notes-smart-paging)을 참조하십시오.

데이터를 가져올 때 정렬하는 경우에도 유사한 방법을 따를 수 있으며, 필드 이름을 _/orders?sort=ProductID_ 같은 값으로 가져오는 정렬 매개 변수를 제공할 수 있습니다. 그러나 이 접근 방식은 캐싱에 나쁜 영향을 미칠 수 있습니다(많은 캐시 구현에서 캐싱된 데이터에 대한 키로 사용하는 리소스 식별자의 쿼리 문자열 매개 변수 형식 부분).

이 접근 방식을 단일 리소스 항목에 대량의 데이터가 포함된 경우 반환되는 필드를 제한하도록 (프로젝트) 확장할 수 있습니다. 예를 들어 쉼표로 구분된 필드 목록을 수락하는 _/orders?fields=ProductID,Quantity_ 같은 쿼리 문자열 매개 변수를 사용할 수 있습니다.

> [AZURE.TIP]쿼리 문자열의 모든 선택적 매개 변수에 의미 있는 기본값을 제공합니다. 예를 들어 페이지 매김을 구현하는 경우 `limit` 매개 변수를 10으로, `offset` 매개 변수를 0으로 설정하고, 주문을 구현하는 경우 정렬 매개 변수를 리소스의 키로 설정하고, 프로젝션을 지원하는 경우 `fields` 매개 변수를 리소스의 모든 필드로 설정합니다.

### 큰 이진 리소스 처리

파일 또는 이미지처럼 단일 리소스가 큰 이진 필드를 포함할 수 있습니다. 신뢰할 수 없고 간헐적인 연결에서 야기되는 전송 문제를 해결하고 응답 시간을 개선하려면 클라이언트 응용 프로그램이 그러한 리소스를 청크로 검색할 수 있는 작업을 제공하는 것이 좋습니다. 이렇게 하려면 웹 API 응용 프로그램이 큰 리소스의 GET 요청에 대해 Accept-Ranges 헤더를 지원해야 하며 이러한 리소스에 대해 HTTP HEAD 요청을 구현하는 것이 최적입니다. Accept-ranges 헤더는 GET 작업이 부분적인 결과를 지원하고 클라이언트 응용 프로그램이 바이트 범위로 지정된 리소스의 하위 집합을 반환하는 GET 요청을 제출할 수 있음을 나타냅니다. HEAD 요청은 리소스 및 빈 메시지 본문을 설명하는 헤더만 반환하는 경우를 제외하고 GET 요청과 비슷합니다. 클라이언트 응용 프로그램은 부분적인 GET 요청을 사용하여 리소스를 가져올지 여부를 결정하는 HEAD 요청을 사용할 수 있습니다. 다음 예제에서는 제품 이미지에 대 한 정보를 얻는 HEAD 요청을 보여 줍니다.

```HTTP
HEAD http://adventure-works.com/products/10?fields=ProductImage HTTP/1.1
...
```

응답 메시지는 리소스의 크기(4580 바이트)가 들어 있는 헤더 및 해당 GET 작업이 일부 결과를 지원하는 Accept-Ranges 헤더를 포함하고 있습니다.

```HTTP
HTTP/1.1 200 OK
...
Accept-Ranges: bytes
Content-Type: image/jpeg
Content-Length: 4580
...
```

클라이언트 응용 프로그램은 이 정보를 사용하여 더 작은 청크에서 이미지를 검색하는 일련의 GET 작업을 구성할 수 있습니다. 첫 번째 요청은 범위 헤더를 사용하여 처음 2500 바이트를 가져옵니다.

```HTTP
GET http://adventure-works.com/products/10?fields=ProductImage HTTP/1.1
Range: bytes=0-2499
...
```

응답 메시지는 HTTP 상태 코드 206을 반환하여 이 응답이 부분 응답임을 나타냅니다. Content-Length 헤더는 메시지 본문에 반환된 실제 바이트 수(리소스의 크기가 아닌)를 지정하며, Content-Range 헤더는 해당 바이트가 리소스의 어느 부분인지(4580 바이트 중 바이트 0-2499)를 나타냅니다.

```HTTP
HTTP/1.1 206 Partial Content
...
Accept-Ranges: bytes
Content-Type: image/jpeg
Content-Length: 2500
Content-Range: bytes 0-2499/4580
...
_{binary data not shown}_
```

클라이언트 응용 프로그램에서 오는 이후 요청은 해당 Range 헤더를 사용하여 리소스의 나머지 부분을 검색할 수 있습니다.

```HTTP
GET http://adventure-works.com/products/10?fields=ProductImage HTTP/1.1
Range: bytes=2500-
...
```

해당하는 결과 메시지는 아래와 같아야 합니다.

```HTTP
HTTP/1.1 206 Partial Content
...
Accept-Ranges: bytes
Content-Type: image/jpeg
Content-Length: 2080
Content-Range: bytes 2500-4580/4580
...
```

## HATEOAS 접근 방식을 사용하여 관련 리소스 탐색 사용

REST를 실행하는 기본적인 동기 중 하나는 URI 체계에 대해 미리 알고 있지 않아도 전체 리소스 집합을 탐색할 수 있어야 하기 때문입니다. 각 HTTP GET 요청은 응답에 포함된 하이퍼링크를 통해 요청된 개체와 직접 관련된 리소스를 찾는 데 필요한 정보를 반환해야 하며, 이러한 각 리소스에 대해 사용할 수 있는 작업을 설명하는 정보도 제공되어야 합니다. 이 원칙을 HATEOAS(Hypertext as the Engine of Application State)라 합니다. 시스템은 실질적으로 유한 상태 시스템으로서, 각 요청에 대한 응답은 한 상태에서 다른 상태로 바꾸는 데 필요한 정보를 포함하고 있으며, 다른 정보는 필요하지 않습니다.

> [AZURE.NOTE]현재 HATEOAS 원칙을 모델링하는 방법을 정의하는 표준 또는 사양은 없습니다. 이 섹션에 나오는 예제에서는 한 가지 가능한 해결 방법을 보여 줍니다.

한 예로, 고객과 주문 간의 관계를 처리하려면 특정 주문에 대한 응답에 반환된 데이터가 주문을 실행한 고객을 식별하는 하이퍼링크 형식의 URI 및 해당 고객에 대해 수행할 수 있는 작업을 포함하고 있어야 합니다.

```HTTP
GET http://adventure-works.com/orders/3 HTTP/1.1
Accept: application/json
...
```

응답 메시지의 본문은 관계의 특성(_Customer_)을 지정하는 `Links` 배열(코드 예제에 강조 표시됨), 고객의 URI(\__http://adventure-works.com/customers/3_)), 이 고객의 세부 정보를 검색하는 방법(_GET_) 및 웹 서버가 이 정보를 검색하기 위해 지원하는 MIME 형식(_text/xml_ 및 _application/json_)을 포함하고 있습니다. 이 정보가 모두 있어야 클라이언트 응용 프로그램이 고객의 세부 정보를 가져올 수 있습니다. 또한 링크 배열은 PUT(고객 수정, 웹 서버가 클라이언트에서 제공할 것으로 기대하는 형식 포함) 및 DELETE 등 수행할 수 있는 다른 작업에 대한 링크도 포함하고 있습니다.

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/json; charset=utf-8
...
Content-Length: ...
{"OrderID":3,"ProductID":2,"Quantity":4,"OrderValue":16.60,"Links":[(some links omitted){"Relationship":"customer","HRef":" http://adventure-works.com/customers/3", "Action":"GET","LinkedResourceMIMETypes":["text/xml","application/json"]},{"Relationship":"
customer","HRef":" http://adventure-works.com /customers/3", "Action":"PUT","LinkedResourceMIMETypes":["application/x-www-form-urlencoded"]},{"Relationship":"customer","HRef":" http://adventure-works.com /customers/3","Action":"DELETE","LinkedResourceMIMETypes":[]}]}
```

완전성을 위해, 링크 배열은 검색된 리소스와 관련된 자체 참조 정보도 포함하고 있어야 합니다. 이러한 링크는 이전 예제에서 생략되었지만, 다음 코드에는 강조 표시되어 있습니다. 이러한 링크에서 관계 _self_를 사용하여 이것이 작업에서 반환되는 리소스에 대한 참조임을 나타냈습니다.

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/json; charset=utf-8
...
Content-Length: ...
{"OrderID":3,"ProductID":2,"Quantity":4,"OrderValue":16.60,"Links":[{"Relationship":"self","HRef":" http://adventure-works.com/orders/3", "Action":"GET","LinkedResourceMIMETypes":["text/xml","application/json"]},{"Relationship":" self","HRef":" http://adventure-works.com /orders/3", "Action":"PUT","LinkedResourceMIMETypes":["application/x-www-form-urlencoded"]},{"Relationship":"self","HRef":" http://adventure-works.com /orders/3", "Action":"DELETE","LinkedResourceMIMETypes":[]},{"Relationship":"customer",
"HRef":" http://adventure-works.com /customers/3", "Action":"GET","LinkedResourceMIMETypes":["text/xml","application/json"]},{"Relationship":" customer" (customer links omitted)}]}
```

이 접근 방식이 효과적으로 적용되려면 이 추가 정보를 검색하고 구문 분석하도록 클라이언트 응용 프로그램을 준비해야 합니다.

## RESTful 웹 API 버전 관리

가장 단순한 상황을 제외하고 웹 API가 정적으로 남아 있을 가능성은 거의 없습니다. 비즈니스 요구 사항이 변경됨에 따라 자원의 새 컬렉션이 추가될 수 있으므로, 리소스 간의 관계가 변할 수 있으며 리소스 데이터의 구조가 수정될 수 있습니다. 웹 API를 새로운 또는 서로 다른 요구 사항을 처리하도록 업데이트하는 동안 해당 변경이 웹 API를 사용하는 클라이언트 응용 프로그램에 미치는 영향을 고려해야 합니다. 문제는 개발자가 해당 API를 완전히 제어할 수 있는 웹 API를 디자인 및 구현하더라도, 해당 개발자는 원격으로 작업하는 제3자 조직이 구축할 수 있는 클라이언트 응용 프로그램을 같은 정도로 제어하지 못한다는 것입니다. 따라서 새 클라이언트 응용 프로그램이 새 기능과 리소스의 장점을 이용할 수 있도록 하면서도 기존 클라이언트 응용 프로그램이 변경되지 않고 계속 작동할 수 있도록 해야 합니다.

버전 관리를 사용하면 웹 API는 자신이 표시하는 기능과 리소스를 나타낼 수 있으며, 클라이언트 응용 프로그램은 기능 또는 리소스의 특정 버전으로 지정된 요청을 제출할 수 있습니다. 다음 섹션에서는 각각 자체의 이점과 절충점을 가지고 있는 다양한 접근 방식을 설명합니다.

### 버전 관리 없음

가장 간단한 방법이며 일부 내부 API에 대해 허용될 수 있습니다. 큰 변화는 새 리소스 또는 새 연결로 나타낼 수 있습니다. 기존 리소스에 콘텐츠를 추가해도 이 콘텐츠가 표시될 것으로 예상하지 않은 클라이언트 응용 프로그램은 해당 콘텐츠를 무시할 것이므로 주요 변경 내용이 표시되지 않을 수 있습니다.

예를 들어 URI \__http://adventure-works.com/customers/3_에 대한 요청은 클라이언트 응용 프로그램이 예상하는 `Id`, `Name` 및 `Address` 필드가 포함된 단일 고객의 세부 정보를 반환해야 합니다.

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/json; charset=utf-8
...
Content-Length: ...
[{"Id":3,"Name":"Contoso LLC","Address":"1 Microsoft Way Redmond WA 98053"}]
```

> [AZURE.NOTE]간단명료하게 하기 위해 이 섹션에 표시된 예제 응답은 HATEOAS 링크를 포함하고 있지 않습니다.

`DateCreated` 필드가 고객 리소스의 체계에 추가되면 응답은 다음과 같습니다.

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/json; charset=utf-8
...
Content-Length: ...
[{"Id":3,"Name":"Contoso LLC","DateCreated":"2014-09-04T12:11:38.0376089Z","Address":"1 Microsoft Way Redmond WA 98053"}]
```

기존 클라이언트 응용 프로그램은 인식되지 않은 필드를 무시할 수 있으면 계속 올바르게 작동할 수 있으며, 한편 새 클라이언트 응용 프로그램을 새 필드를 처리하도록 디자인할 수 있습니다. 그러나 리소스가 더 크게 변경되거나(필드 제거 또는 이름 변경 등) 리소스 간의 관계가 변경된 경우에는 이러한 변화가 주요 변경 내용으로 인식되어 기존 클라이언트 응용 프로그램이 올바르게 작동하지 못할 수 있습니다. 이러한 상황에서는 다음 방법 중 하나를 고려해야 합니다.

### URI 버전 관리

웹 API를 수정하거나 리소스의 체계를 변경할 때마다 각 리소스의 URI에 버전 번호를 추가합니다. 앞에서는 기존 URI가 전과 같이 계속 작동하여 원래 체계를 준수하는 리소스를 반환해야 합니다.

앞의 예제를 확장하여 `Address` 필드가 주소의 각 구성 부분을 포함하고 있는 하위 필드(예: `StreetAddress`, `City`, `State` 및 `ZipCode`)로 재구성된다면, http://adventure-works.com/v2/customers/3과 같은 버전 번호가 들어 있는 URI를 통해 리소스의 이 버전을 표시할 수 있습니다.

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/json; charset=utf-8
...
Content-Length: ...
[{"Id":3,"Name":"Contoso LLC","DateCreated":"2014-09-04T12:11:38.0376089Z","Address":{"StreetAddress":"1 Microsoft Way","City":"Redmond","State":"WA","ZipCode":98053}}]
```

이 버전 관리 메커니즘은 매우 간단하지만 요청을 적절한 끝점으로 라우팅하는 서버에 따라 달라집니다. 그러나 여러 번 반복을 통해 웹 API가 성숙해짐에 따라 이 메커니즘을 다룰 수 없게 될 수 있으며 서버가 다양한 버전을 지원해야 합니다. 또한 엄격히 말해서, 클라이언트 응용 프로그램이 같은 데이터(고객 3)를 가져오므로, URI가 버전에 따라 달라져서는 안 됩니다. 또한 이 체계는 모든 링크가 자신의 URI에 버전 번호를 포함해야 하므로 HATEOAS 구현을 복잡하게 만듭니다.

### 쿼리 문자열 버전 관리

복수 URI를 제공하는 대신에 HTTP 요청에 추가된 쿼리 문자열 내에 \__http://adventure-works.com/customers/3?version=2_ 같은 매개 변수를 사용하여 리소스의 버전을 지정할 수 있습니다. 버전 매개 변수는 이전 클라이언트 응용 프로그램에서 생략했다면 기본적으로 1과 같은 의미 있는 값입니다.

이 접근 방식은 같은 리소스가 언제나 같은 URI에서 검색된다는 의미 체계 장점이 있지만, 쿼리 문자열을 구문 분석하고 해당 HTTP 응답을 다시 보내기 위해 요청을 처리하는 코드에 따라 달라집니다. 또한 이 접근 방식은 HATEOAS를 URI 버전 관리 메커니즘으로 구현할 때와 같이 복잡합니다.

> [AZURE.NOTE]일부 구형 웹 브라우저와 웹 프록시는 URL에 쿼리 문자열을 포함하는 요청에 대한 응답을 캐싱하지 않습니다. 이는 웹 API를 사용하고 해당 웹 브라우저 내에서 실행되는 웹 응용 프로그램의 성능을 저하시킬 수 있습니다.

### 헤더 버전 관리

버전 번호를 쿼리 문자열 매개 변수로 추가하지 않고 리소스의 버전을 나타내는 사용자 지정 헤더를 구현할 수 있습니다. 이 접근 방식을 사용하려면 클라이언트 응용 프로그램이 적절한 헤더를 요청에 추가해야 하지만, version 헤더가 생략된 경우 클라이언트 요청을 처리하는 코드가 기본값(버전 1)을 사용할 수 있습니다. 다음 예제에서는 _Custom-Header_라는 사용자 지정 헤더를 이용합니다. 이 헤더의 값은 웹 API의 버전을 나타냅니다.

버전 1:

```HTTP
GET http://adventure-works.com/customers/3 HTTP/1.1
...
Custom-Header: api-version=1
...
```

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/json; charset=utf-8
...
Content-Length: ...
[{"Id":3,"Name":"Contoso LLC","Address":"1 Microsoft Way Redmond WA 98053"}]
```

버전 2:

```HTTP
GET http://adventure-works.com/customers/3 HTTP/1.1
...
Custom-Header: api-version=2
...
```

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/json; charset=utf-8
...
Content-Length: ...
[{"Id":3,"Name":"Contoso LLC","DateCreated":"2014-09-04T12:11:38.0376089Z","Address":{"StreetAddress":"1 Microsoft Way","City":"Redmond","State":"WA","ZipCode":98053}}]
```

참고로 이전의 두 방법 방식과 마찬가지로 HATEOAS를 구현하려면 모든 링크에 적절한 사용자 지정 헤더를 포함해야 합니다.

### 미디어 형식 버전 관리

이 지침의 앞부분에서 설명한 대로, 클라이언트 응용 프로그램은 웹 서버에 HTTP GET 요청을 보낼 때 Accept 헤더를 사용하여 처리할 수 있는 콘텐츠의 형식을 지정해야 합니다. 흔히 _Accept_ 헤더의 목적은 클라이언트 응용 프로그램에서 응답 본문이 XML, JSON 또는 클라이언트가 구문 분석할 수 있는 몇몇 다른 일반적인 형식 중 어느 형식인지 지정할 수 있도록 하는 것입니다. 그러나 클라이언트 응용 프로그램이 예상하는 리소스의 버전을 나타낼 수 있도록 하는 정보를 포함한 사용자 지정 미디어 형식을 정의할 수 있습니다. 다음 예제는 _Accept_ 헤더를 값 _application/vnd.adventure-works.v1+json_과 함께 지정하는 요청을 나타냅니다. _vnd.adventure-works.v1_ 요소는 웹 서버에 대해 리소스의 버전 1을 반환해야 한다는 것을 나타내며, 한편 _json_ 요소는 응답 본문의 형식이 JSON이어야 함을 지정합니다.

```HTTP
GET http://adventure-works.com/customers/3 HTTP/1.1
...
Accept: application/vnd.adventure-works.v1+json
...
```

요청을 처리하는 코드는 _Accept_ 헤더를 처리하고 가능하면 해당 헤더를 적용해야 합니다. 클라이언트 응용 프로그램은 _Accept_ 헤더에 복수의 형식을 지정할 수 있으며, 이 경우 웹 서버는 응답 본문에 가장 적절한 형식을 선택할 수 있습니다. 웹 서버는 Content-Type 헤더를 사용하여 응답 본문에 있는 데이터의 형식을 확인합니다.

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/vnd.adventure-works.v1+json; charset=utf-8
...
Content-Length: ...
[{"Id":3,"Name":"Contoso LLC","Address":"1 Microsoft Way Redmond WA 98053"}]
```

Accept 헤더가 모든 알려진 미디어 형식을 지정하지 않은 경우, 웹 서버는 HTTP 406(승인 금지) 응답 메시지를 생성하거나 기본 미디어 형식이 포함된 메시지를 반환할 수 있습니다.

이 접근 방식은 엄격히 말해서 버전 관리 메커니즘인지 여부에 대한 논란의 여지가 있으며 당연히 리소스 링크에 관련 데이터의 MIME 형식을 포함할 수 있는 HATEOAS에 적합합니다.

> [AZURE.NOTE]버전 관리 전략을 선택할 때에는 성능에 미치는 영향, 특히 웹 서버의 캐싱을 고려해야 합니다. URI 버전 관리 및 쿼리 문자열 버전 관리 체계는 같은 URI/쿼리 문자열 조합이 매번 같은 데이터를 참조하므로 캐싱하기에 적합합니다.

> 일반적으로 헤더 버전 관리 및 미디어 형식 버전 관리 메커니즘에는 사용자 지정 헤더 또는 Accept 헤더의 값을 검사하기 위해 추가 논리가 필요합니다. 대규모 환경의 경우, 서로 다른 버전의 웹 API를 사용하는 많은 클라이언트가 서버 쪽 캐시에 상당한 양의 중복된 데이터를 발생시킬 수 있습니다. 클라이언트 응용 프로그램이 캐싱을 구현하는 프록시를 통해 웹 서버와 통신하는 경우 이 문제가 심각할 수 있으며, 현재 요청된 데이터의 복사본을 자체의 캐시에 저장하지 않은 경우에만 요청을 웹 서버에 전달해야 합니다.

## 자세한 정보

- [RESTful Cookbook](http://restcookbook.com/)은 RESTful API를 구축하는 방법을 소개합니다.
- 웹 [API 검사 목록](https://mathieu.fenniak.net/the-api-checklist/)에 웹 API를 디자인 및 구현할 때 고려할 유용한 항목 목록이 있습니다.

<!---HONumber=Oct15_HO3-->